// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace libsignal.state {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class StorageProtos {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure, global::libsignal.state.StorageProtos.SessionStructure.Builder> internal__static_textsecure_SessionStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure_Chain__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder> internal__static_textsecure_SessionStructure_Chain__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure_Chain_ChainKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.Builder> internal__static_textsecure_SessionStructure_Chain_ChainKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure_Chain_MessageKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.Builder> internal__static_textsecure_SessionStructure_Chain_MessageKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure_PendingKeyExchange__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange, global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.Builder> internal__static_textsecure_SessionStructure_PendingKeyExchange__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SessionStructure_PendingPreKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey, global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.Builder> internal__static_textsecure_SessionStructure_PendingPreKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_RecordStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.RecordStructure, global::libsignal.state.StorageProtos.RecordStructure.Builder> internal__static_textsecure_RecordStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_PreKeyRecordStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.PreKeyRecordStructure, global::libsignal.state.StorageProtos.PreKeyRecordStructure.Builder> internal__static_textsecure_PreKeyRecordStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SignedPreKeyRecordStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure, global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure.Builder> internal__static_textsecure_SignedPreKeyRecordStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_IdentityKeyPairStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.IdentityKeyPairStructure, global::libsignal.state.StorageProtos.IdentityKeyPairStructure.Builder> internal__static_textsecure_IdentityKeyPairStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SenderKeyStateStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Builder> internal__static_textsecure_SenderKeyStateStructure__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.Builder> internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.Builder> internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.Builder> internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_textsecure_SenderKeyRecordStructure__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyRecordStructure, global::libsignal.state.StorageProtos.SenderKeyRecordStructure.Builder> internal__static_textsecure_SenderKeyRecordStructure__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static StorageProtos() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChpMb2NhbFN0b3JhZ2VQcm90b2NvbC5wcm90bxIKdGV4dHNlY3VyZSLTCAoQ", 
            "U2Vzc2lvblN0cnVjdHVyZRIWCg5zZXNzaW9uVmVyc2lvbhgBIAEoDRIbChNs", 
            "b2NhbElkZW50aXR5UHVibGljGAIgASgMEhwKFHJlbW90ZUlkZW50aXR5UHVi", 
            "bGljGAMgASgMEg8KB3Jvb3RLZXkYBCABKAwSFwoPcHJldmlvdXNDb3VudGVy", 
            "GAUgASgNEjcKC3NlbmRlckNoYWluGAYgASgLMiIudGV4dHNlY3VyZS5TZXNz", 
            "aW9uU3RydWN0dXJlLkNoYWluEjoKDnJlY2VpdmVyQ2hhaW5zGAcgAygLMiIu", 
            "dGV4dHNlY3VyZS5TZXNzaW9uU3RydWN0dXJlLkNoYWluEksKEnBlbmRpbmdL", 
            "ZXlFeGNoYW5nZRgIIAEoCzIvLnRleHRzZWN1cmUuU2Vzc2lvblN0cnVjdHVy", 
            "ZS5QZW5kaW5nS2V5RXhjaGFuZ2USQQoNcGVuZGluZ1ByZUtleRgJIAEoCzIq", 
            "LnRleHRzZWN1cmUuU2Vzc2lvblN0cnVjdHVyZS5QZW5kaW5nUHJlS2V5EhwK", 
            "FHJlbW90ZVJlZ2lzdHJhdGlvbklkGAogASgNEhsKE2xvY2FsUmVnaXN0cmF0", 
            "aW9uSWQYCyABKA0SFAoMbmVlZHNSZWZyZXNoGAwgASgIEhQKDGFsaWNlQmFz", 
            "ZUtleRgNIAEoDBq5AgoFQ2hhaW4SGAoQc2VuZGVyUmF0Y2hldEtleRgBIAEo", 
            "DBIfChdzZW5kZXJSYXRjaGV0S2V5UHJpdmF0ZRgCIAEoDBI9CghjaGFpbktl", 
            "eRgDIAEoCzIrLnRleHRzZWN1cmUuU2Vzc2lvblN0cnVjdHVyZS5DaGFpbi5D", 
            "aGFpbktleRJCCgttZXNzYWdlS2V5cxgEIAMoCzItLnRleHRzZWN1cmUuU2Vz", 
            "c2lvblN0cnVjdHVyZS5DaGFpbi5NZXNzYWdlS2V5GiYKCENoYWluS2V5Eg0K", 
            "BWluZGV4GAEgASgNEgsKA2tleRgCIAEoDBpKCgpNZXNzYWdlS2V5Eg0KBWlu", 
            "ZGV4GAEgASgNEhEKCWNpcGhlcktleRgCIAEoDBIOCgZtYWNLZXkYAyABKAwS", 
            "CgoCaXYYBCABKAwazQEKElBlbmRpbmdLZXlFeGNoYW5nZRIQCghzZXF1ZW5j", 
            "ZRgBIAEoDRIUCgxsb2NhbEJhc2VLZXkYAiABKAwSGwoTbG9jYWxCYXNlS2V5", 
            "UHJpdmF0ZRgDIAEoDBIXCg9sb2NhbFJhdGNoZXRLZXkYBCABKAwSHgoWbG9j", 
            "YWxSYXRjaGV0S2V5UHJpdmF0ZRgFIAEoDBIYChBsb2NhbElkZW50aXR5S2V5", 
            "GAcgASgMEh8KF2xvY2FsSWRlbnRpdHlLZXlQcml2YXRlGAggASgMGkoKDVBl", 
            "bmRpbmdQcmVLZXkSEAoIcHJlS2V5SWQYASABKA0SFgoOc2lnbmVkUHJlS2V5", 
            "SWQYAyABKAUSDwoHYmFzZUtleRgCIAEoDCJ/Cg9SZWNvcmRTdHJ1Y3R1cmUS", 
            "NAoOY3VycmVudFNlc3Npb24YASABKAsyHC50ZXh0c2VjdXJlLlNlc3Npb25T", 
            "dHJ1Y3R1cmUSNgoQcHJldmlvdXNTZXNzaW9ucxgCIAMoCzIcLnRleHRzZWN1", 
            "cmUuU2Vzc2lvblN0cnVjdHVyZSJKChVQcmVLZXlSZWNvcmRTdHJ1Y3R1cmUS", 
            "CgoCaWQYASABKA0SEQoJcHVibGljS2V5GAIgASgMEhIKCnByaXZhdGVLZXkY", 
            "AyABKAwidgobU2lnbmVkUHJlS2V5UmVjb3JkU3RydWN0dXJlEgoKAmlkGAEg", 
            "ASgNEhEKCXB1YmxpY0tleRgCIAEoDBISCgpwcml2YXRlS2V5GAMgASgMEhEK", 
            "CXNpZ25hdHVyZRgEIAEoDBIRCgl0aW1lc3RhbXAYBSABKAYiQQoYSWRlbnRp", 
            "dHlLZXlQYWlyU3RydWN0dXJlEhEKCXB1YmxpY0tleRgBIAEoDBISCgpwcml2", 
            "YXRlS2V5GAIgASgMIrgDChdTZW5kZXJLZXlTdGF0ZVN0cnVjdHVyZRITCgtz", 
            "ZW5kZXJLZXlJZBgBIAEoDRJKCg5zZW5kZXJDaGFpbktleRgCIAEoCzIyLnRl", 
            "eHRzZWN1cmUuU2VuZGVyS2V5U3RhdGVTdHJ1Y3R1cmUuU2VuZGVyQ2hhaW5L", 
            "ZXkSTgoQc2VuZGVyU2lnbmluZ0tleRgDIAEoCzI0LnRleHRzZWN1cmUuU2Vu", 
            "ZGVyS2V5U3RhdGVTdHJ1Y3R1cmUuU2VuZGVyU2lnbmluZ0tleRJPChFzZW5k", 
            "ZXJNZXNzYWdlS2V5cxgEIAMoCzI0LnRleHRzZWN1cmUuU2VuZGVyS2V5U3Rh", 
            "dGVTdHJ1Y3R1cmUuU2VuZGVyTWVzc2FnZUtleRoxCg5TZW5kZXJDaGFpbktl", 
            "eRIRCglpdGVyYXRpb24YASABKA0SDAoEc2VlZBgCIAEoDBozChBTZW5kZXJN", 
            "ZXNzYWdlS2V5EhEKCWl0ZXJhdGlvbhgBIAEoDRIMCgRzZWVkGAIgASgMGjMK", 
            "EFNlbmRlclNpZ25pbmdLZXkSDgoGcHVibGljGAEgASgMEg8KB3ByaXZhdGUY", 
            "AiABKAwiWAoYU2VuZGVyS2V5UmVjb3JkU3RydWN0dXJlEjwKD3NlbmRlcktl", 
            "eVN0YXRlcxgBIAMoCzIjLnRleHRzZWN1cmUuU2VuZGVyS2V5U3RhdGVTdHJ1", 
          "Y3R1cmU="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_textsecure_SessionStructure__Descriptor = Descriptor.MessageTypes[0];
        internal__static_textsecure_SessionStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure, global::libsignal.state.StorageProtos.SessionStructure.Builder>(internal__static_textsecure_SessionStructure__Descriptor,
                new string[] { "SessionVersion", "LocalIdentityPublic", "RemoteIdentityPublic", "RootKey", "PreviousCounter", "SenderChain", "ReceiverChains", "PendingKeyExchange", "PendingPreKey", "RemoteRegistrationId", "LocalRegistrationId", "NeedsRefresh", "AliceBaseKey", });
        internal__static_textsecure_SessionStructure_Chain__Descriptor = internal__static_textsecure_SessionStructure__Descriptor.NestedTypes[0];
        internal__static_textsecure_SessionStructure_Chain__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder>(internal__static_textsecure_SessionStructure_Chain__Descriptor,
                new string[] { "SenderRatchetKey", "SenderRatchetKeyPrivate", "ChainKey", "MessageKeys", });
        internal__static_textsecure_SessionStructure_Chain_ChainKey__Descriptor = internal__static_textsecure_SessionStructure_Chain__Descriptor.NestedTypes[0];
        internal__static_textsecure_SessionStructure_Chain_ChainKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.Builder>(internal__static_textsecure_SessionStructure_Chain_ChainKey__Descriptor,
                new string[] { "Index", "Key", });
        internal__static_textsecure_SessionStructure_Chain_MessageKey__Descriptor = internal__static_textsecure_SessionStructure_Chain__Descriptor.NestedTypes[1];
        internal__static_textsecure_SessionStructure_Chain_MessageKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.Builder>(internal__static_textsecure_SessionStructure_Chain_MessageKey__Descriptor,
                new string[] { "Index", "CipherKey", "MacKey", "Iv", });
        internal__static_textsecure_SessionStructure_PendingKeyExchange__Descriptor = internal__static_textsecure_SessionStructure__Descriptor.NestedTypes[1];
        internal__static_textsecure_SessionStructure_PendingKeyExchange__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange, global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.Builder>(internal__static_textsecure_SessionStructure_PendingKeyExchange__Descriptor,
                new string[] { "Sequence", "LocalBaseKey", "LocalBaseKeyPrivate", "LocalRatchetKey", "LocalRatchetKeyPrivate", "LocalIdentityKey", "LocalIdentityKeyPrivate", });
        internal__static_textsecure_SessionStructure_PendingPreKey__Descriptor = internal__static_textsecure_SessionStructure__Descriptor.NestedTypes[2];
        internal__static_textsecure_SessionStructure_PendingPreKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey, global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.Builder>(internal__static_textsecure_SessionStructure_PendingPreKey__Descriptor,
                new string[] { "PreKeyId", "SignedPreKeyId", "BaseKey", });
        internal__static_textsecure_RecordStructure__Descriptor = Descriptor.MessageTypes[1];
        internal__static_textsecure_RecordStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.RecordStructure, global::libsignal.state.StorageProtos.RecordStructure.Builder>(internal__static_textsecure_RecordStructure__Descriptor,
                new string[] { "CurrentSession", "PreviousSessions", });
        internal__static_textsecure_PreKeyRecordStructure__Descriptor = Descriptor.MessageTypes[2];
        internal__static_textsecure_PreKeyRecordStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.PreKeyRecordStructure, global::libsignal.state.StorageProtos.PreKeyRecordStructure.Builder>(internal__static_textsecure_PreKeyRecordStructure__Descriptor,
                new string[] { "Id", "PublicKey", "PrivateKey", });
        internal__static_textsecure_SignedPreKeyRecordStructure__Descriptor = Descriptor.MessageTypes[3];
        internal__static_textsecure_SignedPreKeyRecordStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure, global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure.Builder>(internal__static_textsecure_SignedPreKeyRecordStructure__Descriptor,
                new string[] { "Id", "PublicKey", "PrivateKey", "Signature", "Timestamp", });
        internal__static_textsecure_IdentityKeyPairStructure__Descriptor = Descriptor.MessageTypes[4];
        internal__static_textsecure_IdentityKeyPairStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.IdentityKeyPairStructure, global::libsignal.state.StorageProtos.IdentityKeyPairStructure.Builder>(internal__static_textsecure_IdentityKeyPairStructure__Descriptor,
                new string[] { "PublicKey", "PrivateKey", });
        internal__static_textsecure_SenderKeyStateStructure__Descriptor = Descriptor.MessageTypes[5];
        internal__static_textsecure_SenderKeyStateStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Builder>(internal__static_textsecure_SenderKeyStateStructure__Descriptor,
                new string[] { "SenderKeyId", "SenderChainKey", "SenderSigningKey", "SenderMessageKeys", });
        internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__Descriptor = internal__static_textsecure_SenderKeyStateStructure__Descriptor.NestedTypes[0];
        internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.Builder>(internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__Descriptor,
                new string[] { "Iteration", "Seed", });
        internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__Descriptor = internal__static_textsecure_SenderKeyStateStructure__Descriptor.NestedTypes[1];
        internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.Builder>(internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__Descriptor,
                new string[] { "Iteration", "Seed", });
        internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__Descriptor = internal__static_textsecure_SenderKeyStateStructure__Descriptor.NestedTypes[2];
        internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.Builder>(internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__Descriptor,
                new string[] { "Public", "Private", });
        internal__static_textsecure_SenderKeyRecordStructure__Descriptor = Descriptor.MessageTypes[6];
        internal__static_textsecure_SenderKeyRecordStructure__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.state.StorageProtos.SenderKeyRecordStructure, global::libsignal.state.StorageProtos.SenderKeyRecordStructure.Builder>(internal__static_textsecure_SenderKeyRecordStructure__Descriptor,
                new string[] { "SenderKeyStates", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
    #region Messages
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SessionStructure : pb::GeneratedMessage<SessionStructure, SessionStructure.Builder> {
      private SessionStructure() { }
      private static readonly SessionStructure defaultInstance = new SessionStructure().MakeReadOnly();
      private static readonly string[] _sessionStructureFieldNames = new string[] { "aliceBaseKey", "localIdentityPublic", "localRegistrationId", "needsRefresh", "pendingKeyExchange", "pendingPreKey", "previousCounter", "receiverChains", "remoteIdentityPublic", "remoteRegistrationId", "rootKey", "senderChain", "sessionVersion" };
      private static readonly uint[] _sessionStructureFieldTags = new uint[] { 106, 18, 88, 96, 66, 74, 40, 58, 26, 80, 34, 50, 8 };
      public static SessionStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SessionStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SessionStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SessionStructure, SessionStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Chain : pb::GeneratedMessage<Chain, Chain.Builder> {
          private Chain() { }
          private static readonly Chain defaultInstance = new Chain().MakeReadOnly();
          private static readonly string[] _chainFieldNames = new string[] { "chainKey", "messageKeys", "senderRatchetKey", "senderRatchetKeyPrivate" };
          private static readonly uint[] _chainFieldTags = new uint[] { 26, 34, 10, 18 };
          public static Chain DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override Chain DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override Chain ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<Chain, Chain.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain__FieldAccessorTable; }
          }
          
          #region Nested types
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public static partial class Types {
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class ChainKey : pb::GeneratedMessage<ChainKey, ChainKey.Builder> {
              private ChainKey() { }
              private static readonly ChainKey defaultInstance = new ChainKey().MakeReadOnly();
              private static readonly string[] _chainKeyFieldNames = new string[] { "index", "key" };
              private static readonly uint[] _chainKeyFieldTags = new uint[] { 8, 18 };
              public static ChainKey DefaultInstance {
                get { return defaultInstance; }
              }
              
              public override ChainKey DefaultInstanceForType {
                get { return DefaultInstance; }
              }
              
              protected override ChainKey ThisMessage {
                get { return this; }
              }
              
              public static pbd::MessageDescriptor Descriptor {
                get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain_ChainKey__Descriptor; }
              }
              
              protected override pb::FieldAccess.FieldAccessorTable<ChainKey, ChainKey.Builder> InternalFieldAccessors {
                get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain_ChainKey__FieldAccessorTable; }
              }
              
              public const int IndexFieldNumber = 1;
              private bool hasIndex;
              private uint index_;
              public bool HasIndex {
                get { return hasIndex; }
              }
              [global::System.CLSCompliant(false)]
              public uint Index {
                get { return index_; }
              }
              
              public const int KeyFieldNumber = 2;
              private bool hasKey;
              private pb::ByteString key_ = pb::ByteString.Empty;
              public bool HasKey {
                get { return hasKey; }
              }
              public pb::ByteString Key {
                get { return key_; }
              }
              
              public override bool IsInitialized {
                get {
                  return true;
                }
              }
              
              public override void WriteTo(pb::ICodedOutputStream output) {
                CalcSerializedSize();
                string[] field_names = _chainKeyFieldNames;
                if (hasIndex) {
                  output.WriteUInt32(1, field_names[0], Index);
                }
                if (hasKey) {
                  output.WriteBytes(2, field_names[1], Key);
                }
                UnknownFields.WriteTo(output);
              }
              
              private int memoizedSerializedSize = -1;
              public override int SerializedSize {
                get {
                  int size = memoizedSerializedSize;
                  if (size != -1) return size;
                  return CalcSerializedSize();
                }
              }
              
              private int CalcSerializedSize() {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                
                size = 0;
                if (hasIndex) {
                  size += pb::CodedOutputStream.ComputeUInt32Size(1, Index);
                }
                if (hasKey) {
                  size += pb::CodedOutputStream.ComputeBytesSize(2, Key);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
              }
              public static ChainKey ParseFrom(pb::ByteString data) {
                return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
              }
              public static ChainKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
              }
              public static ChainKey ParseFrom(byte[] data) {
                return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
              }
              public static ChainKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
              }
              public static ChainKey ParseFrom(global::System.IO.Stream input) {
                return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
              }
              public static ChainKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
              }
              public static ChainKey ParseDelimitedFrom(global::System.IO.Stream input) {
                return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
              }
              public static ChainKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
                return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
              }
              public static ChainKey ParseFrom(pb::ICodedInputStream input) {
                return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
              }
              public static ChainKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
              }
              private ChainKey MakeReadOnly() {
                return this;
              }
              
              public static Builder CreateBuilder() { return new Builder(); }
              public override Builder ToBuilder() { return CreateBuilder(this); }
              public override Builder CreateBuilderForType() { return new Builder(); }
              public static Builder CreateBuilder(ChainKey prototype) {
                return new Builder(prototype);
              }
              
              [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
              public sealed partial class Builder : pb::GeneratedBuilder<ChainKey, Builder> {
                protected override Builder ThisBuilder {
                  get { return this; }
                }
                public Builder() {
                  result = DefaultInstance;
                  resultIsReadOnly = true;
                }
                internal Builder(ChainKey cloneFrom) {
                  result = cloneFrom;
                  resultIsReadOnly = true;
                }
                
                private bool resultIsReadOnly;
                private ChainKey result;
                
                private ChainKey PrepareBuilder() {
                  if (resultIsReadOnly) {
                    ChainKey original = result;
                    result = new ChainKey();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                  }
                  return result;
                }
                
                public override bool IsInitialized {
                  get { return result.IsInitialized; }
                }
                
                protected override ChainKey MessageBeingBuilt {
                  get { return PrepareBuilder(); }
                }
                
                public override Builder Clear() {
                  result = DefaultInstance;
                  resultIsReadOnly = true;
                  return this;
                }
                
                public override Builder Clone() {
                  if (resultIsReadOnly) {
                    return new Builder(result);
                  } else {
                    return new Builder().MergeFrom(result);
                  }
                }
                
                public override pbd::MessageDescriptor DescriptorForType {
                  get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.Descriptor; }
                }
                
                public override ChainKey DefaultInstanceForType {
                  get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.DefaultInstance; }
                }
                
                public override ChainKey BuildPartial() {
                  if (resultIsReadOnly) {
                    return result;
                  }
                  resultIsReadOnly = true;
                  return result.MakeReadOnly();
                }
                
                public override Builder MergeFrom(pb::IMessage other) {
                  if (other is ChainKey) {
                    return MergeFrom((ChainKey) other);
                  } else {
                    base.MergeFrom(other);
                    return this;
                  }
                }
                
                public override Builder MergeFrom(ChainKey other) {
                  if (other == DefaultInstance) return this;
                  PrepareBuilder();
                  if (other.HasIndex) {
                    Index = other.Index;
                  }
                  if (other.HasKey) {
                    Key = other.Key;
                  }
                                    MergeUnknownFields(other.UnknownFields);
                  return this;
                }
                
                public override Builder MergeFrom(pb::ICodedInputStream input) {
                  return MergeFrom(input, pb::ExtensionRegistry.Empty);
                }
                
                public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
                  PrepareBuilder();
                  pb::UnknownFieldSet.Builder unknownFields = null;
                  uint tag;
                  string field_name;
                  while (input.ReadTag(out tag, out field_name)) {
                    if(tag == 0 && field_name != null) {
                      int field_ordinal = global::System.Array.BinarySearch(_chainKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                      if(field_ordinal >= 0)
                        tag = _chainKeyFieldTags[field_ordinal];
                      else {
                        if (unknownFields == null) {
                          unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                        }
                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                        continue;
                      }
                    }
                    switch (tag) {
                      case 0: {
                        throw pb::InvalidProtocolBufferException.InvalidTag();
                      }
                      default: {
                        if (pb::WireFormat.IsEndGroupTag(tag)) {
                          if (unknownFields != null) {
                                                            UnknownFields = unknownFields.Build();
                          }
                          return this;
                        }
                        if (unknownFields == null) {
                          unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                        }
                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                        break;
                      }
                      case 8: {
                        result.hasIndex = input.ReadUInt32(ref result.index_);
                        break;
                      }
                      case 18: {
                        result.hasKey = input.ReadBytes(ref result.key_);
                        break;
                      }
                    }
                  }
                  
                  if (unknownFields != null) {
                                        UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                
                
                public bool HasIndex {
                  get { return result.hasIndex; }
                }
                [global::System.CLSCompliant(false)]
                public uint Index {
                  get { return result.Index; }
                  set { SetIndex(value); }
                }
                [global::System.CLSCompliant(false)]
                public Builder SetIndex(uint value) {
                  PrepareBuilder();
                  result.hasIndex = true;
                  result.index_ = value;
                  return this;
                }
                public Builder ClearIndex() {
                  PrepareBuilder();
                  result.hasIndex = false;
                  result.index_ = 0;
                  return this;
                }
                
                public bool HasKey {
                  get { return result.hasKey; }
                }
                public pb::ByteString Key {
                  get { return result.Key; }
                  set { SetKey(value); }
                }
                public Builder SetKey(pb::ByteString value) {
                  pb::ThrowHelper.ThrowIfNull(value, "value");
                  PrepareBuilder();
                  result.hasKey = true;
                  result.key_ = value;
                  return this;
                }
                public Builder ClearKey() {
                  PrepareBuilder();
                  result.hasKey = false;
                  result.key_ = pb::ByteString.Empty;
                  return this;
                }
              }
              static ChainKey() {
                object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
              }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class MessageKey : pb::GeneratedMessage<MessageKey, MessageKey.Builder> {
              private MessageKey() { }
              private static readonly MessageKey defaultInstance = new MessageKey().MakeReadOnly();
              private static readonly string[] _messageKeyFieldNames = new string[] { "cipherKey", "index", "iv", "macKey" };
              private static readonly uint[] _messageKeyFieldTags = new uint[] { 18, 8, 34, 26 };
              public static MessageKey DefaultInstance {
                get { return defaultInstance; }
              }
              
              public override MessageKey DefaultInstanceForType {
                get { return DefaultInstance; }
              }
              
              protected override MessageKey ThisMessage {
                get { return this; }
              }
              
              public static pbd::MessageDescriptor Descriptor {
                get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain_MessageKey__Descriptor; }
              }
              
              protected override pb::FieldAccess.FieldAccessorTable<MessageKey, MessageKey.Builder> InternalFieldAccessors {
                get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_Chain_MessageKey__FieldAccessorTable; }
              }
              
              public const int IndexFieldNumber = 1;
              private bool hasIndex;
              private uint index_;
              public bool HasIndex {
                get { return hasIndex; }
              }
              [global::System.CLSCompliant(false)]
              public uint Index {
                get { return index_; }
              }
              
              public const int CipherKeyFieldNumber = 2;
              private bool hasCipherKey;
              private pb::ByteString cipherKey_ = pb::ByteString.Empty;
              public bool HasCipherKey {
                get { return hasCipherKey; }
              }
              public pb::ByteString CipherKey {
                get { return cipherKey_; }
              }
              
              public const int MacKeyFieldNumber = 3;
              private bool hasMacKey;
              private pb::ByteString macKey_ = pb::ByteString.Empty;
              public bool HasMacKey {
                get { return hasMacKey; }
              }
              public pb::ByteString MacKey {
                get { return macKey_; }
              }
              
              public const int IvFieldNumber = 4;
              private bool hasIv;
              private pb::ByteString iv_ = pb::ByteString.Empty;
              public bool HasIv {
                get { return hasIv; }
              }
              public pb::ByteString Iv {
                get { return iv_; }
              }
              
              public override bool IsInitialized {
                get {
                  return true;
                }
              }
              
              public override void WriteTo(pb::ICodedOutputStream output) {
                CalcSerializedSize();
                string[] field_names = _messageKeyFieldNames;
                if (hasIndex) {
                  output.WriteUInt32(1, field_names[1], Index);
                }
                if (hasCipherKey) {
                  output.WriteBytes(2, field_names[0], CipherKey);
                }
                if (hasMacKey) {
                  output.WriteBytes(3, field_names[3], MacKey);
                }
                if (hasIv) {
                  output.WriteBytes(4, field_names[2], Iv);
                }
                UnknownFields.WriteTo(output);
              }
              
              private int memoizedSerializedSize = -1;
              public override int SerializedSize {
                get {
                  int size = memoizedSerializedSize;
                  if (size != -1) return size;
                  return CalcSerializedSize();
                }
              }
              
              private int CalcSerializedSize() {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                
                size = 0;
                if (hasIndex) {
                  size += pb::CodedOutputStream.ComputeUInt32Size(1, Index);
                }
                if (hasCipherKey) {
                  size += pb::CodedOutputStream.ComputeBytesSize(2, CipherKey);
                }
                if (hasMacKey) {
                  size += pb::CodedOutputStream.ComputeBytesSize(3, MacKey);
                }
                if (hasIv) {
                  size += pb::CodedOutputStream.ComputeBytesSize(4, Iv);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
              }
              public static MessageKey ParseFrom(pb::ByteString data) {
                return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
              }
              public static MessageKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
              }
              public static MessageKey ParseFrom(byte[] data) {
                return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
              }
              public static MessageKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
              }
              public static MessageKey ParseFrom(global::System.IO.Stream input) {
                return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
              }
              public static MessageKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
              }
              public static MessageKey ParseDelimitedFrom(global::System.IO.Stream input) {
                return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
              }
              public static MessageKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
                return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
              }
              public static MessageKey ParseFrom(pb::ICodedInputStream input) {
                return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
              }
              public static MessageKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
                return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
              }
              private MessageKey MakeReadOnly() {
                return this;
              }
              
              public static Builder CreateBuilder() { return new Builder(); }
              public override Builder ToBuilder() { return CreateBuilder(this); }
              public override Builder CreateBuilderForType() { return new Builder(); }
              public static Builder CreateBuilder(MessageKey prototype) {
                return new Builder(prototype);
              }
              
              [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
              public sealed partial class Builder : pb::GeneratedBuilder<MessageKey, Builder> {
                protected override Builder ThisBuilder {
                  get { return this; }
                }
                public Builder() {
                  result = DefaultInstance;
                  resultIsReadOnly = true;
                }
                internal Builder(MessageKey cloneFrom) {
                  result = cloneFrom;
                  resultIsReadOnly = true;
                }
                
                private bool resultIsReadOnly;
                private MessageKey result;
                
                private MessageKey PrepareBuilder() {
                  if (resultIsReadOnly) {
                    MessageKey original = result;
                    result = new MessageKey();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                  }
                  return result;
                }
                
                public override bool IsInitialized {
                  get { return result.IsInitialized; }
                }
                
                protected override MessageKey MessageBeingBuilt {
                  get { return PrepareBuilder(); }
                }
                
                public override Builder Clear() {
                  result = DefaultInstance;
                  resultIsReadOnly = true;
                  return this;
                }
                
                public override Builder Clone() {
                  if (resultIsReadOnly) {
                    return new Builder(result);
                  } else {
                    return new Builder().MergeFrom(result);
                  }
                }
                
                public override pbd::MessageDescriptor DescriptorForType {
                  get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.Descriptor; }
                }
                
                public override MessageKey DefaultInstanceForType {
                  get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.DefaultInstance; }
                }
                
                public override MessageKey BuildPartial() {
                  if (resultIsReadOnly) {
                    return result;
                  }
                  resultIsReadOnly = true;
                  return result.MakeReadOnly();
                }
                
                public override Builder MergeFrom(pb::IMessage other) {
                  if (other is MessageKey) {
                    return MergeFrom((MessageKey) other);
                  } else {
                    base.MergeFrom(other);
                    return this;
                  }
                }
                
                public override Builder MergeFrom(MessageKey other) {
                  if (other == DefaultInstance) return this;
                  PrepareBuilder();
                  if (other.HasIndex) {
                    Index = other.Index;
                  }
                  if (other.HasCipherKey) {
                    CipherKey = other.CipherKey;
                  }
                  if (other.HasMacKey) {
                    MacKey = other.MacKey;
                  }
                  if (other.HasIv) {
                    Iv = other.Iv;
                  }
                                    MergeUnknownFields(other.UnknownFields);
                  return this;
                }
                
                public override Builder MergeFrom(pb::ICodedInputStream input) {
                  return MergeFrom(input, pb::ExtensionRegistry.Empty);
                }
                
                public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
                  PrepareBuilder();
                  pb::UnknownFieldSet.Builder unknownFields = null;
                  uint tag;
                  string field_name;
                  while (input.ReadTag(out tag, out field_name)) {
                    if(tag == 0 && field_name != null) {
                      int field_ordinal = global::System.Array.BinarySearch(_messageKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                      if(field_ordinal >= 0)
                        tag = _messageKeyFieldTags[field_ordinal];
                      else {
                        if (unknownFields == null) {
                          unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                        }
                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                        continue;
                      }
                    }
                    switch (tag) {
                      case 0: {
                        throw pb::InvalidProtocolBufferException.InvalidTag();
                      }
                      default: {
                        if (pb::WireFormat.IsEndGroupTag(tag)) {
                          if (unknownFields != null) {
                                                            UnknownFields = unknownFields.Build();
                          }
                          return this;
                        }
                        if (unknownFields == null) {
                          unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                        }
                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                        break;
                      }
                      case 8: {
                        result.hasIndex = input.ReadUInt32(ref result.index_);
                        break;
                      }
                      case 18: {
                        result.hasCipherKey = input.ReadBytes(ref result.cipherKey_);
                        break;
                      }
                      case 26: {
                        result.hasMacKey = input.ReadBytes(ref result.macKey_);
                        break;
                      }
                      case 34: {
                        result.hasIv = input.ReadBytes(ref result.iv_);
                        break;
                      }
                    }
                  }
                  
                  if (unknownFields != null) {
                                        UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                
                
                public bool HasIndex {
                  get { return result.hasIndex; }
                }
                [global::System.CLSCompliant(false)]
                public uint Index {
                  get { return result.Index; }
                  set { SetIndex(value); }
                }
                [global::System.CLSCompliant(false)]
                public Builder SetIndex(uint value) {
                  PrepareBuilder();
                  result.hasIndex = true;
                  result.index_ = value;
                  return this;
                }
                public Builder ClearIndex() {
                  PrepareBuilder();
                  result.hasIndex = false;
                  result.index_ = 0;
                  return this;
                }
                
                public bool HasCipherKey {
                  get { return result.hasCipherKey; }
                }
                public pb::ByteString CipherKey {
                  get { return result.CipherKey; }
                  set { SetCipherKey(value); }
                }
                public Builder SetCipherKey(pb::ByteString value) {
                  pb::ThrowHelper.ThrowIfNull(value, "value");
                  PrepareBuilder();
                  result.hasCipherKey = true;
                  result.cipherKey_ = value;
                  return this;
                }
                public Builder ClearCipherKey() {
                  PrepareBuilder();
                  result.hasCipherKey = false;
                  result.cipherKey_ = pb::ByteString.Empty;
                  return this;
                }
                
                public bool HasMacKey {
                  get { return result.hasMacKey; }
                }
                public pb::ByteString MacKey {
                  get { return result.MacKey; }
                  set { SetMacKey(value); }
                }
                public Builder SetMacKey(pb::ByteString value) {
                  pb::ThrowHelper.ThrowIfNull(value, "value");
                  PrepareBuilder();
                  result.hasMacKey = true;
                  result.macKey_ = value;
                  return this;
                }
                public Builder ClearMacKey() {
                  PrepareBuilder();
                  result.hasMacKey = false;
                  result.macKey_ = pb::ByteString.Empty;
                  return this;
                }
                
                public bool HasIv {
                  get { return result.hasIv; }
                }
                public pb::ByteString Iv {
                  get { return result.Iv; }
                  set { SetIv(value); }
                }
                public Builder SetIv(pb::ByteString value) {
                  pb::ThrowHelper.ThrowIfNull(value, "value");
                  PrepareBuilder();
                  result.hasIv = true;
                  result.iv_ = value;
                  return this;
                }
                public Builder ClearIv() {
                  PrepareBuilder();
                  result.hasIv = false;
                  result.iv_ = pb::ByteString.Empty;
                  return this;
                }
              }
              static MessageKey() {
                object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
              }
            }
            
          }
          #endregion
          
          public const int SenderRatchetKeyFieldNumber = 1;
          private bool hasSenderRatchetKey;
          private pb::ByteString senderRatchetKey_ = pb::ByteString.Empty;
          public bool HasSenderRatchetKey {
            get { return hasSenderRatchetKey; }
          }
          public pb::ByteString SenderRatchetKey {
            get { return senderRatchetKey_; }
          }
          
          public const int SenderRatchetKeyPrivateFieldNumber = 2;
          private bool hasSenderRatchetKeyPrivate;
          private pb::ByteString senderRatchetKeyPrivate_ = pb::ByteString.Empty;
          public bool HasSenderRatchetKeyPrivate {
            get { return hasSenderRatchetKeyPrivate; }
          }
          public pb::ByteString SenderRatchetKeyPrivate {
            get { return senderRatchetKeyPrivate_; }
          }
          
          public const int ChainKeyFieldNumber = 3;
          private bool hasChainKey;
          private global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey chainKey_;
          public bool HasChainKey {
            get { return hasChainKey; }
          }
          public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey ChainKey {
            get { return chainKey_ ?? global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.DefaultInstance; }
          }
          
          public const int MessageKeysFieldNumber = 4;
          private pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey> messageKeys_ = new pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey>();
          public scg::IList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey> MessageKeysList {
            get { return messageKeys_; }
          }
          public int MessageKeysCount {
            get { return messageKeys_.Count; }
          }
          public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey GetMessageKeys(int index) {
            return messageKeys_[index];
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _chainFieldNames;
            if (hasSenderRatchetKey) {
              output.WriteBytes(1, field_names[2], SenderRatchetKey);
            }
            if (hasSenderRatchetKeyPrivate) {
              output.WriteBytes(2, field_names[3], SenderRatchetKeyPrivate);
            }
            if (hasChainKey) {
              output.WriteMessage(3, field_names[0], ChainKey);
            }
            if (messageKeys_.Count > 0) {
              output.WriteMessageArray(4, field_names[1], messageKeys_);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasSenderRatchetKey) {
              size += pb::CodedOutputStream.ComputeBytesSize(1, SenderRatchetKey);
            }
            if (hasSenderRatchetKeyPrivate) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, SenderRatchetKeyPrivate);
            }
            if (hasChainKey) {
              size += pb::CodedOutputStream.ComputeMessageSize(3, ChainKey);
            }
            foreach (global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey element in MessageKeysList) {
              size += pb::CodedOutputStream.ComputeMessageSize(4, element);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static Chain ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static Chain ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static Chain ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static Chain ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static Chain ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static Chain ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static Chain ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static Chain ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static Chain ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static Chain ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private Chain MakeReadOnly() {
            messageKeys_.MakeReadOnly();
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(Chain prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<Chain, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(Chain cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private Chain result;
            
            private Chain PrepareBuilder() {
              if (resultIsReadOnly) {
                Chain original = result;
                result = new Chain();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override Chain MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Descriptor; }
            }
            
            public override Chain DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.DefaultInstance; }
            }
            
            public override Chain BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is Chain) {
                return MergeFrom((Chain) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(Chain other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasSenderRatchetKey) {
                SenderRatchetKey = other.SenderRatchetKey;
              }
              if (other.HasSenderRatchetKeyPrivate) {
                SenderRatchetKeyPrivate = other.SenderRatchetKeyPrivate;
              }
              if (other.HasChainKey) {
                MergeChainKey(other.ChainKey);
              }
              if (other.messageKeys_.Count != 0) {
                result.messageKeys_.Add(other.messageKeys_);
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_chainFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _chainFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 10: {
                    result.hasSenderRatchetKey = input.ReadBytes(ref result.senderRatchetKey_);
                    break;
                  }
                  case 18: {
                    result.hasSenderRatchetKeyPrivate = input.ReadBytes(ref result.senderRatchetKeyPrivate_);
                    break;
                  }
                  case 26: {
                    global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.Builder subBuilder = global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.CreateBuilder();
                    if (result.hasChainKey) {
                      subBuilder.MergeFrom(ChainKey);
                    }
                    input.ReadMessage(subBuilder, extensionRegistry);
                    ChainKey = subBuilder.BuildPartial();
                    break;
                  }
                  case 34: {
                    input.ReadMessageArray(tag, field_name, result.messageKeys_, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.DefaultInstance, extensionRegistry);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasSenderRatchetKey {
              get { return result.hasSenderRatchetKey; }
            }
            public pb::ByteString SenderRatchetKey {
              get { return result.SenderRatchetKey; }
              set { SetSenderRatchetKey(value); }
            }
            public Builder SetSenderRatchetKey(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasSenderRatchetKey = true;
              result.senderRatchetKey_ = value;
              return this;
            }
            public Builder ClearSenderRatchetKey() {
              PrepareBuilder();
              result.hasSenderRatchetKey = false;
              result.senderRatchetKey_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasSenderRatchetKeyPrivate {
              get { return result.hasSenderRatchetKeyPrivate; }
            }
            public pb::ByteString SenderRatchetKeyPrivate {
              get { return result.SenderRatchetKeyPrivate; }
              set { SetSenderRatchetKeyPrivate(value); }
            }
            public Builder SetSenderRatchetKeyPrivate(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasSenderRatchetKeyPrivate = true;
              result.senderRatchetKeyPrivate_ = value;
              return this;
            }
            public Builder ClearSenderRatchetKeyPrivate() {
              PrepareBuilder();
              result.hasSenderRatchetKeyPrivate = false;
              result.senderRatchetKeyPrivate_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasChainKey {
             get { return result.hasChainKey; }
            }
            public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey ChainKey {
              get { return result.ChainKey; }
              set { SetChainKey(value); }
            }
            public Builder SetChainKey(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasChainKey = true;
              result.chainKey_ = value;
              return this;
            }
            public Builder SetChainKey(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.Builder builderForValue) {
              pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
              PrepareBuilder();
              result.hasChainKey = true;
              result.chainKey_ = builderForValue.Build();
              return this;
            }
            public Builder MergeChainKey(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              if (result.hasChainKey &&
                  result.chainKey_ != global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.DefaultInstance) {
                  result.chainKey_ = global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.ChainKey.CreateBuilder(result.chainKey_).MergeFrom(value).BuildPartial();
              } else {
                result.chainKey_ = value;
              }
              result.hasChainKey = true;
              return this;
            }
            public Builder ClearChainKey() {
              PrepareBuilder();
              result.hasChainKey = false;
              result.chainKey_ = null;
              return this;
            }
            
            public pbc::IPopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey> MessageKeysList {
              get { return PrepareBuilder().messageKeys_; }
            }
            public int MessageKeysCount {
              get { return result.MessageKeysCount; }
            }
            public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey GetMessageKeys(int index) {
              return result.GetMessageKeys(index);
            }
            public Builder SetMessageKeys(int index, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.messageKeys_[index] = value;
              return this;
            }
            public Builder SetMessageKeys(int index, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.Builder builderForValue) {
              pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
              PrepareBuilder();
              result.messageKeys_[index] = builderForValue.Build();
              return this;
            }
            public Builder AddMessageKeys(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.messageKeys_.Add(value);
              return this;
            }
            public Builder AddMessageKeys(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey.Builder builderForValue) {
              pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
              PrepareBuilder();
              result.messageKeys_.Add(builderForValue.Build());
              return this;
            }
            public Builder AddRangeMessageKeys(scg::IEnumerable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Types.MessageKey> values) {
              PrepareBuilder();
              result.messageKeys_.Add(values);
              return this;
            }
            public Builder ClearMessageKeys() {
              PrepareBuilder();
              result.messageKeys_.Clear();
              return this;
            }
          }
          static Chain() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class PendingKeyExchange : pb::GeneratedMessage<PendingKeyExchange, PendingKeyExchange.Builder> {
          private PendingKeyExchange() { }
          private static readonly PendingKeyExchange defaultInstance = new PendingKeyExchange().MakeReadOnly();
          private static readonly string[] _pendingKeyExchangeFieldNames = new string[] { "localBaseKey", "localBaseKeyPrivate", "localIdentityKey", "localIdentityKeyPrivate", "localRatchetKey", "localRatchetKeyPrivate", "sequence" };
          private static readonly uint[] _pendingKeyExchangeFieldTags = new uint[] { 18, 26, 58, 66, 34, 42, 8 };
          public static PendingKeyExchange DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override PendingKeyExchange DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override PendingKeyExchange ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_PendingKeyExchange__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<PendingKeyExchange, PendingKeyExchange.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_PendingKeyExchange__FieldAccessorTable; }
          }
          
          public const int SequenceFieldNumber = 1;
          private bool hasSequence;
          private uint sequence_;
          public bool HasSequence {
            get { return hasSequence; }
          }
          [global::System.CLSCompliant(false)]
          public uint Sequence {
            get { return sequence_; }
          }
          
          public const int LocalBaseKeyFieldNumber = 2;
          private bool hasLocalBaseKey;
          private pb::ByteString localBaseKey_ = pb::ByteString.Empty;
          public bool HasLocalBaseKey {
            get { return hasLocalBaseKey; }
          }
          public pb::ByteString LocalBaseKey {
            get { return localBaseKey_; }
          }
          
          public const int LocalBaseKeyPrivateFieldNumber = 3;
          private bool hasLocalBaseKeyPrivate;
          private pb::ByteString localBaseKeyPrivate_ = pb::ByteString.Empty;
          public bool HasLocalBaseKeyPrivate {
            get { return hasLocalBaseKeyPrivate; }
          }
          public pb::ByteString LocalBaseKeyPrivate {
            get { return localBaseKeyPrivate_; }
          }
          
          public const int LocalRatchetKeyFieldNumber = 4;
          private bool hasLocalRatchetKey;
          private pb::ByteString localRatchetKey_ = pb::ByteString.Empty;
          public bool HasLocalRatchetKey {
            get { return hasLocalRatchetKey; }
          }
          public pb::ByteString LocalRatchetKey {
            get { return localRatchetKey_; }
          }
          
          public const int LocalRatchetKeyPrivateFieldNumber = 5;
          private bool hasLocalRatchetKeyPrivate;
          private pb::ByteString localRatchetKeyPrivate_ = pb::ByteString.Empty;
          public bool HasLocalRatchetKeyPrivate {
            get { return hasLocalRatchetKeyPrivate; }
          }
          public pb::ByteString LocalRatchetKeyPrivate {
            get { return localRatchetKeyPrivate_; }
          }
          
          public const int LocalIdentityKeyFieldNumber = 7;
          private bool hasLocalIdentityKey;
          private pb::ByteString localIdentityKey_ = pb::ByteString.Empty;
          public bool HasLocalIdentityKey {
            get { return hasLocalIdentityKey; }
          }
          public pb::ByteString LocalIdentityKey {
            get { return localIdentityKey_; }
          }
          
          public const int LocalIdentityKeyPrivateFieldNumber = 8;
          private bool hasLocalIdentityKeyPrivate;
          private pb::ByteString localIdentityKeyPrivate_ = pb::ByteString.Empty;
          public bool HasLocalIdentityKeyPrivate {
            get { return hasLocalIdentityKeyPrivate; }
          }
          public pb::ByteString LocalIdentityKeyPrivate {
            get { return localIdentityKeyPrivate_; }
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _pendingKeyExchangeFieldNames;
            if (hasSequence) {
              output.WriteUInt32(1, field_names[6], Sequence);
            }
            if (hasLocalBaseKey) {
              output.WriteBytes(2, field_names[0], LocalBaseKey);
            }
            if (hasLocalBaseKeyPrivate) {
              output.WriteBytes(3, field_names[1], LocalBaseKeyPrivate);
            }
            if (hasLocalRatchetKey) {
              output.WriteBytes(4, field_names[4], LocalRatchetKey);
            }
            if (hasLocalRatchetKeyPrivate) {
              output.WriteBytes(5, field_names[5], LocalRatchetKeyPrivate);
            }
            if (hasLocalIdentityKey) {
              output.WriteBytes(7, field_names[2], LocalIdentityKey);
            }
            if (hasLocalIdentityKeyPrivate) {
              output.WriteBytes(8, field_names[3], LocalIdentityKeyPrivate);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasSequence) {
              size += pb::CodedOutputStream.ComputeUInt32Size(1, Sequence);
            }
            if (hasLocalBaseKey) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, LocalBaseKey);
            }
            if (hasLocalBaseKeyPrivate) {
              size += pb::CodedOutputStream.ComputeBytesSize(3, LocalBaseKeyPrivate);
            }
            if (hasLocalRatchetKey) {
              size += pb::CodedOutputStream.ComputeBytesSize(4, LocalRatchetKey);
            }
            if (hasLocalRatchetKeyPrivate) {
              size += pb::CodedOutputStream.ComputeBytesSize(5, LocalRatchetKeyPrivate);
            }
            if (hasLocalIdentityKey) {
              size += pb::CodedOutputStream.ComputeBytesSize(7, LocalIdentityKey);
            }
            if (hasLocalIdentityKeyPrivate) {
              size += pb::CodedOutputStream.ComputeBytesSize(8, LocalIdentityKeyPrivate);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static PendingKeyExchange ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static PendingKeyExchange ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static PendingKeyExchange ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static PendingKeyExchange ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private PendingKeyExchange MakeReadOnly() {
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(PendingKeyExchange prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<PendingKeyExchange, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(PendingKeyExchange cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private PendingKeyExchange result;
            
            private PendingKeyExchange PrepareBuilder() {
              if (resultIsReadOnly) {
                PendingKeyExchange original = result;
                result = new PendingKeyExchange();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override PendingKeyExchange MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.Descriptor; }
            }
            
            public override PendingKeyExchange DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.DefaultInstance; }
            }
            
            public override PendingKeyExchange BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is PendingKeyExchange) {
                return MergeFrom((PendingKeyExchange) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(PendingKeyExchange other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasSequence) {
                Sequence = other.Sequence;
              }
              if (other.HasLocalBaseKey) {
                LocalBaseKey = other.LocalBaseKey;
              }
              if (other.HasLocalBaseKeyPrivate) {
                LocalBaseKeyPrivate = other.LocalBaseKeyPrivate;
              }
              if (other.HasLocalRatchetKey) {
                LocalRatchetKey = other.LocalRatchetKey;
              }
              if (other.HasLocalRatchetKeyPrivate) {
                LocalRatchetKeyPrivate = other.LocalRatchetKeyPrivate;
              }
              if (other.HasLocalIdentityKey) {
                LocalIdentityKey = other.LocalIdentityKey;
              }
              if (other.HasLocalIdentityKeyPrivate) {
                LocalIdentityKeyPrivate = other.LocalIdentityKeyPrivate;
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_pendingKeyExchangeFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _pendingKeyExchangeFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 8: {
                    result.hasSequence = input.ReadUInt32(ref result.sequence_);
                    break;
                  }
                  case 18: {
                    result.hasLocalBaseKey = input.ReadBytes(ref result.localBaseKey_);
                    break;
                  }
                  case 26: {
                    result.hasLocalBaseKeyPrivate = input.ReadBytes(ref result.localBaseKeyPrivate_);
                    break;
                  }
                  case 34: {
                    result.hasLocalRatchetKey = input.ReadBytes(ref result.localRatchetKey_);
                    break;
                  }
                  case 42: {
                    result.hasLocalRatchetKeyPrivate = input.ReadBytes(ref result.localRatchetKeyPrivate_);
                    break;
                  }
                  case 58: {
                    result.hasLocalIdentityKey = input.ReadBytes(ref result.localIdentityKey_);
                    break;
                  }
                  case 66: {
                    result.hasLocalIdentityKeyPrivate = input.ReadBytes(ref result.localIdentityKeyPrivate_);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasSequence {
              get { return result.hasSequence; }
            }
            [global::System.CLSCompliant(false)]
            public uint Sequence {
              get { return result.Sequence; }
              set { SetSequence(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetSequence(uint value) {
              PrepareBuilder();
              result.hasSequence = true;
              result.sequence_ = value;
              return this;
            }
            public Builder ClearSequence() {
              PrepareBuilder();
              result.hasSequence = false;
              result.sequence_ = 0;
              return this;
            }
            
            public bool HasLocalBaseKey {
              get { return result.hasLocalBaseKey; }
            }
            public pb::ByteString LocalBaseKey {
              get { return result.LocalBaseKey; }
              set { SetLocalBaseKey(value); }
            }
            public Builder SetLocalBaseKey(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalBaseKey = true;
              result.localBaseKey_ = value;
              return this;
            }
            public Builder ClearLocalBaseKey() {
              PrepareBuilder();
              result.hasLocalBaseKey = false;
              result.localBaseKey_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasLocalBaseKeyPrivate {
              get { return result.hasLocalBaseKeyPrivate; }
            }
            public pb::ByteString LocalBaseKeyPrivate {
              get { return result.LocalBaseKeyPrivate; }
              set { SetLocalBaseKeyPrivate(value); }
            }
            public Builder SetLocalBaseKeyPrivate(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalBaseKeyPrivate = true;
              result.localBaseKeyPrivate_ = value;
              return this;
            }
            public Builder ClearLocalBaseKeyPrivate() {
              PrepareBuilder();
              result.hasLocalBaseKeyPrivate = false;
              result.localBaseKeyPrivate_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasLocalRatchetKey {
              get { return result.hasLocalRatchetKey; }
            }
            public pb::ByteString LocalRatchetKey {
              get { return result.LocalRatchetKey; }
              set { SetLocalRatchetKey(value); }
            }
            public Builder SetLocalRatchetKey(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalRatchetKey = true;
              result.localRatchetKey_ = value;
              return this;
            }
            public Builder ClearLocalRatchetKey() {
              PrepareBuilder();
              result.hasLocalRatchetKey = false;
              result.localRatchetKey_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasLocalRatchetKeyPrivate {
              get { return result.hasLocalRatchetKeyPrivate; }
            }
            public pb::ByteString LocalRatchetKeyPrivate {
              get { return result.LocalRatchetKeyPrivate; }
              set { SetLocalRatchetKeyPrivate(value); }
            }
            public Builder SetLocalRatchetKeyPrivate(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalRatchetKeyPrivate = true;
              result.localRatchetKeyPrivate_ = value;
              return this;
            }
            public Builder ClearLocalRatchetKeyPrivate() {
              PrepareBuilder();
              result.hasLocalRatchetKeyPrivate = false;
              result.localRatchetKeyPrivate_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasLocalIdentityKey {
              get { return result.hasLocalIdentityKey; }
            }
            public pb::ByteString LocalIdentityKey {
              get { return result.LocalIdentityKey; }
              set { SetLocalIdentityKey(value); }
            }
            public Builder SetLocalIdentityKey(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalIdentityKey = true;
              result.localIdentityKey_ = value;
              return this;
            }
            public Builder ClearLocalIdentityKey() {
              PrepareBuilder();
              result.hasLocalIdentityKey = false;
              result.localIdentityKey_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasLocalIdentityKeyPrivate {
              get { return result.hasLocalIdentityKeyPrivate; }
            }
            public pb::ByteString LocalIdentityKeyPrivate {
              get { return result.LocalIdentityKeyPrivate; }
              set { SetLocalIdentityKeyPrivate(value); }
            }
            public Builder SetLocalIdentityKeyPrivate(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasLocalIdentityKeyPrivate = true;
              result.localIdentityKeyPrivate_ = value;
              return this;
            }
            public Builder ClearLocalIdentityKeyPrivate() {
              PrepareBuilder();
              result.hasLocalIdentityKeyPrivate = false;
              result.localIdentityKeyPrivate_ = pb::ByteString.Empty;
              return this;
            }
          }
          static PendingKeyExchange() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class PendingPreKey : pb::GeneratedMessage<PendingPreKey, PendingPreKey.Builder> {
          private PendingPreKey() { }
          private static readonly PendingPreKey defaultInstance = new PendingPreKey().MakeReadOnly();
          private static readonly string[] _pendingPreKeyFieldNames = new string[] { "baseKey", "preKeyId", "signedPreKeyId" };
          private static readonly uint[] _pendingPreKeyFieldTags = new uint[] { 18, 8, 24 };
          public static PendingPreKey DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override PendingPreKey DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override PendingPreKey ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_PendingPreKey__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<PendingPreKey, PendingPreKey.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SessionStructure_PendingPreKey__FieldAccessorTable; }
          }
          
          public const int PreKeyIdFieldNumber = 1;
          private bool hasPreKeyId;
          private uint preKeyId_;
          public bool HasPreKeyId {
            get { return hasPreKeyId; }
          }
          [global::System.CLSCompliant(false)]
          public uint PreKeyId {
            get { return preKeyId_; }
          }
          
          public const int SignedPreKeyIdFieldNumber = 3;
          private bool hasSignedPreKeyId;
          private int signedPreKeyId_;
          public bool HasSignedPreKeyId {
            get { return hasSignedPreKeyId; }
          }
          public int SignedPreKeyId {
            get { return signedPreKeyId_; }
          }
          
          public const int BaseKeyFieldNumber = 2;
          private bool hasBaseKey;
          private pb::ByteString baseKey_ = pb::ByteString.Empty;
          public bool HasBaseKey {
            get { return hasBaseKey; }
          }
          public pb::ByteString BaseKey {
            get { return baseKey_; }
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _pendingPreKeyFieldNames;
            if (hasPreKeyId) {
              output.WriteUInt32(1, field_names[1], PreKeyId);
            }
            if (hasBaseKey) {
              output.WriteBytes(2, field_names[0], BaseKey);
            }
            if (hasSignedPreKeyId) {
              output.WriteInt32(3, field_names[2], SignedPreKeyId);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasPreKeyId) {
              size += pb::CodedOutputStream.ComputeUInt32Size(1, PreKeyId);
            }
            if (hasSignedPreKeyId) {
              size += pb::CodedOutputStream.ComputeInt32Size(3, SignedPreKeyId);
            }
            if (hasBaseKey) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, BaseKey);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static PendingPreKey ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static PendingPreKey ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static PendingPreKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static PendingPreKey ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static PendingPreKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private PendingPreKey MakeReadOnly() {
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(PendingPreKey prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<PendingPreKey, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(PendingPreKey cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private PendingPreKey result;
            
            private PendingPreKey PrepareBuilder() {
              if (resultIsReadOnly) {
                PendingPreKey original = result;
                result = new PendingPreKey();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override PendingPreKey MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.Descriptor; }
            }
            
            public override PendingPreKey DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.DefaultInstance; }
            }
            
            public override PendingPreKey BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is PendingPreKey) {
                return MergeFrom((PendingPreKey) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(PendingPreKey other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasPreKeyId) {
                PreKeyId = other.PreKeyId;
              }
              if (other.HasSignedPreKeyId) {
                SignedPreKeyId = other.SignedPreKeyId;
              }
              if (other.HasBaseKey) {
                BaseKey = other.BaseKey;
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_pendingPreKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _pendingPreKeyFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 8: {
                    result.hasPreKeyId = input.ReadUInt32(ref result.preKeyId_);
                    break;
                  }
                  case 18: {
                    result.hasBaseKey = input.ReadBytes(ref result.baseKey_);
                    break;
                  }
                  case 24: {
                    result.hasSignedPreKeyId = input.ReadInt32(ref result.signedPreKeyId_);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasPreKeyId {
              get { return result.hasPreKeyId; }
            }
            [global::System.CLSCompliant(false)]
            public uint PreKeyId {
              get { return result.PreKeyId; }
              set { SetPreKeyId(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetPreKeyId(uint value) {
              PrepareBuilder();
              result.hasPreKeyId = true;
              result.preKeyId_ = value;
              return this;
            }
            public Builder ClearPreKeyId() {
              PrepareBuilder();
              result.hasPreKeyId = false;
              result.preKeyId_ = 0;
              return this;
            }
            
            public bool HasSignedPreKeyId {
              get { return result.hasSignedPreKeyId; }
            }
            public int SignedPreKeyId {
              get { return result.SignedPreKeyId; }
              set { SetSignedPreKeyId(value); }
            }
            public Builder SetSignedPreKeyId(int value) {
              PrepareBuilder();
              result.hasSignedPreKeyId = true;
              result.signedPreKeyId_ = value;
              return this;
            }
            public Builder ClearSignedPreKeyId() {
              PrepareBuilder();
              result.hasSignedPreKeyId = false;
              result.signedPreKeyId_ = 0;
              return this;
            }
            
            public bool HasBaseKey {
              get { return result.hasBaseKey; }
            }
            public pb::ByteString BaseKey {
              get { return result.BaseKey; }
              set { SetBaseKey(value); }
            }
            public Builder SetBaseKey(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasBaseKey = true;
              result.baseKey_ = value;
              return this;
            }
            public Builder ClearBaseKey() {
              PrepareBuilder();
              result.hasBaseKey = false;
              result.baseKey_ = pb::ByteString.Empty;
              return this;
            }
          }
          static PendingPreKey() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
      }
      #endregion
      
      public const int SessionVersionFieldNumber = 1;
      private bool hasSessionVersion;
      private uint sessionVersion_;
      public bool HasSessionVersion {
        get { return hasSessionVersion; }
      }
      [global::System.CLSCompliant(false)]
      public uint SessionVersion {
        get { return sessionVersion_; }
      }
      
      public const int LocalIdentityPublicFieldNumber = 2;
      private bool hasLocalIdentityPublic;
      private pb::ByteString localIdentityPublic_ = pb::ByteString.Empty;
      public bool HasLocalIdentityPublic {
        get { return hasLocalIdentityPublic; }
      }
      public pb::ByteString LocalIdentityPublic {
        get { return localIdentityPublic_; }
      }
      
      public const int RemoteIdentityPublicFieldNumber = 3;
      private bool hasRemoteIdentityPublic;
      private pb::ByteString remoteIdentityPublic_ = pb::ByteString.Empty;
      public bool HasRemoteIdentityPublic {
        get { return hasRemoteIdentityPublic; }
      }
      public pb::ByteString RemoteIdentityPublic {
        get { return remoteIdentityPublic_; }
      }
      
      public const int RootKeyFieldNumber = 4;
      private bool hasRootKey;
      private pb::ByteString rootKey_ = pb::ByteString.Empty;
      public bool HasRootKey {
        get { return hasRootKey; }
      }
      public pb::ByteString RootKey {
        get { return rootKey_; }
      }
      
      public const int PreviousCounterFieldNumber = 5;
      private bool hasPreviousCounter;
      private uint previousCounter_;
      public bool HasPreviousCounter {
        get { return hasPreviousCounter; }
      }
      [global::System.CLSCompliant(false)]
      public uint PreviousCounter {
        get { return previousCounter_; }
      }
      
      public const int SenderChainFieldNumber = 6;
      private bool hasSenderChain;
      private global::libsignal.state.StorageProtos.SessionStructure.Types.Chain senderChain_;
      public bool HasSenderChain {
        get { return hasSenderChain; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain SenderChain {
        get { return senderChain_ ?? global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.DefaultInstance; }
      }
      
      public const int ReceiverChainsFieldNumber = 7;
      private pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain> receiverChains_ = new pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain>();
      public scg::IList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain> ReceiverChainsList {
        get { return receiverChains_; }
      }
      public int ReceiverChainsCount {
        get { return receiverChains_.Count; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain GetReceiverChains(int index) {
        return receiverChains_[index];
      }
      
      public const int PendingKeyExchangeFieldNumber = 8;
      private bool hasPendingKeyExchange;
      private global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange pendingKeyExchange_;
      public bool HasPendingKeyExchange {
        get { return hasPendingKeyExchange; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange PendingKeyExchange {
        get { return pendingKeyExchange_ ?? global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.DefaultInstance; }
      }
      
      public const int PendingPreKeyFieldNumber = 9;
      private bool hasPendingPreKey;
      private global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey pendingPreKey_;
      public bool HasPendingPreKey {
        get { return hasPendingPreKey; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey PendingPreKey {
        get { return pendingPreKey_ ?? global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.DefaultInstance; }
      }
      
      public const int RemoteRegistrationIdFieldNumber = 10;
      private bool hasRemoteRegistrationId;
      private uint remoteRegistrationId_;
      public bool HasRemoteRegistrationId {
        get { return hasRemoteRegistrationId; }
      }
      [global::System.CLSCompliant(false)]
      public uint RemoteRegistrationId {
        get { return remoteRegistrationId_; }
      }
      
      public const int LocalRegistrationIdFieldNumber = 11;
      private bool hasLocalRegistrationId;
      private uint localRegistrationId_;
      public bool HasLocalRegistrationId {
        get { return hasLocalRegistrationId; }
      }
      [global::System.CLSCompliant(false)]
      public uint LocalRegistrationId {
        get { return localRegistrationId_; }
      }
      
      public const int NeedsRefreshFieldNumber = 12;
      private bool hasNeedsRefresh;
      private bool needsRefresh_;
      public bool HasNeedsRefresh {
        get { return hasNeedsRefresh; }
      }
      public bool NeedsRefresh {
        get { return needsRefresh_; }
      }
      
      public const int AliceBaseKeyFieldNumber = 13;
      private bool hasAliceBaseKey;
      private pb::ByteString aliceBaseKey_ = pb::ByteString.Empty;
      public bool HasAliceBaseKey {
        get { return hasAliceBaseKey; }
      }
      public pb::ByteString AliceBaseKey {
        get { return aliceBaseKey_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _sessionStructureFieldNames;
        if (hasSessionVersion) {
          output.WriteUInt32(1, field_names[12], SessionVersion);
        }
        if (hasLocalIdentityPublic) {
          output.WriteBytes(2, field_names[1], LocalIdentityPublic);
        }
        if (hasRemoteIdentityPublic) {
          output.WriteBytes(3, field_names[8], RemoteIdentityPublic);
        }
        if (hasRootKey) {
          output.WriteBytes(4, field_names[10], RootKey);
        }
        if (hasPreviousCounter) {
          output.WriteUInt32(5, field_names[6], PreviousCounter);
        }
        if (hasSenderChain) {
          output.WriteMessage(6, field_names[11], SenderChain);
        }
        if (receiverChains_.Count > 0) {
          output.WriteMessageArray(7, field_names[7], receiverChains_);
        }
        if (hasPendingKeyExchange) {
          output.WriteMessage(8, field_names[4], PendingKeyExchange);
        }
        if (hasPendingPreKey) {
          output.WriteMessage(9, field_names[5], PendingPreKey);
        }
        if (hasRemoteRegistrationId) {
          output.WriteUInt32(10, field_names[9], RemoteRegistrationId);
        }
        if (hasLocalRegistrationId) {
          output.WriteUInt32(11, field_names[2], LocalRegistrationId);
        }
        if (hasNeedsRefresh) {
          output.WriteBool(12, field_names[3], NeedsRefresh);
        }
        if (hasAliceBaseKey) {
          output.WriteBytes(13, field_names[0], AliceBaseKey);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSessionVersion) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, SessionVersion);
        }
        if (hasLocalIdentityPublic) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, LocalIdentityPublic);
        }
        if (hasRemoteIdentityPublic) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, RemoteIdentityPublic);
        }
        if (hasRootKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, RootKey);
        }
        if (hasPreviousCounter) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, PreviousCounter);
        }
        if (hasSenderChain) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, SenderChain);
        }
        foreach (global::libsignal.state.StorageProtos.SessionStructure.Types.Chain element in ReceiverChainsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, element);
        }
        if (hasPendingKeyExchange) {
          size += pb::CodedOutputStream.ComputeMessageSize(8, PendingKeyExchange);
        }
        if (hasPendingPreKey) {
          size += pb::CodedOutputStream.ComputeMessageSize(9, PendingPreKey);
        }
        if (hasRemoteRegistrationId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(10, RemoteRegistrationId);
        }
        if (hasLocalRegistrationId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(11, LocalRegistrationId);
        }
        if (hasNeedsRefresh) {
          size += pb::CodedOutputStream.ComputeBoolSize(12, NeedsRefresh);
        }
        if (hasAliceBaseKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(13, AliceBaseKey);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SessionStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SessionStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SessionStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SessionStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SessionStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SessionStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SessionStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SessionStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SessionStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SessionStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SessionStructure MakeReadOnly() {
        receiverChains_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SessionStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SessionStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SessionStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SessionStructure result;
        
        private SessionStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            SessionStructure original = result;
            result = new SessionStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SessionStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.SessionStructure.Descriptor; }
        }
        
        public override SessionStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.SessionStructure.DefaultInstance; }
        }
        
        public override SessionStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SessionStructure) {
            return MergeFrom((SessionStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SessionStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasSessionVersion) {
            SessionVersion = other.SessionVersion;
          }
          if (other.HasLocalIdentityPublic) {
            LocalIdentityPublic = other.LocalIdentityPublic;
          }
          if (other.HasRemoteIdentityPublic) {
            RemoteIdentityPublic = other.RemoteIdentityPublic;
          }
          if (other.HasRootKey) {
            RootKey = other.RootKey;
          }
          if (other.HasPreviousCounter) {
            PreviousCounter = other.PreviousCounter;
          }
          if (other.HasSenderChain) {
            MergeSenderChain(other.SenderChain);
          }
          if (other.receiverChains_.Count != 0) {
            result.receiverChains_.Add(other.receiverChains_);
          }
          if (other.HasPendingKeyExchange) {
            MergePendingKeyExchange(other.PendingKeyExchange);
          }
          if (other.HasPendingPreKey) {
            MergePendingPreKey(other.PendingPreKey);
          }
          if (other.HasRemoteRegistrationId) {
            RemoteRegistrationId = other.RemoteRegistrationId;
          }
          if (other.HasLocalRegistrationId) {
            LocalRegistrationId = other.LocalRegistrationId;
          }
          if (other.HasNeedsRefresh) {
            NeedsRefresh = other.NeedsRefresh;
          }
          if (other.HasAliceBaseKey) {
            AliceBaseKey = other.AliceBaseKey;
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_sessionStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _sessionStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasSessionVersion = input.ReadUInt32(ref result.sessionVersion_);
                break;
              }
              case 18: {
                result.hasLocalIdentityPublic = input.ReadBytes(ref result.localIdentityPublic_);
                break;
              }
              case 26: {
                result.hasRemoteIdentityPublic = input.ReadBytes(ref result.remoteIdentityPublic_);
                break;
              }
              case 34: {
                result.hasRootKey = input.ReadBytes(ref result.rootKey_);
                break;
              }
              case 40: {
                result.hasPreviousCounter = input.ReadUInt32(ref result.previousCounter_);
                break;
              }
              case 50: {
                global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder subBuilder = global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.CreateBuilder();
                if (result.hasSenderChain) {
                  subBuilder.MergeFrom(SenderChain);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                SenderChain = subBuilder.BuildPartial();
                break;
              }
              case 58: {
                input.ReadMessageArray(tag, field_name, result.receiverChains_, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.DefaultInstance, extensionRegistry);
                break;
              }
              case 66: {
                global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.Builder subBuilder = global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.CreateBuilder();
                if (result.hasPendingKeyExchange) {
                  subBuilder.MergeFrom(PendingKeyExchange);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                PendingKeyExchange = subBuilder.BuildPartial();
                break;
              }
              case 74: {
                global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.Builder subBuilder = global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.CreateBuilder();
                if (result.hasPendingPreKey) {
                  subBuilder.MergeFrom(PendingPreKey);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                PendingPreKey = subBuilder.BuildPartial();
                break;
              }
              case 80: {
                result.hasRemoteRegistrationId = input.ReadUInt32(ref result.remoteRegistrationId_);
                break;
              }
              case 88: {
                result.hasLocalRegistrationId = input.ReadUInt32(ref result.localRegistrationId_);
                break;
              }
              case 96: {
                result.hasNeedsRefresh = input.ReadBool(ref result.needsRefresh_);
                break;
              }
              case 106: {
                result.hasAliceBaseKey = input.ReadBytes(ref result.aliceBaseKey_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasSessionVersion {
          get { return result.hasSessionVersion; }
        }
        [global::System.CLSCompliant(false)]
        public uint SessionVersion {
          get { return result.SessionVersion; }
          set { SetSessionVersion(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetSessionVersion(uint value) {
          PrepareBuilder();
          result.hasSessionVersion = true;
          result.sessionVersion_ = value;
          return this;
        }
        public Builder ClearSessionVersion() {
          PrepareBuilder();
          result.hasSessionVersion = false;
          result.sessionVersion_ = 0;
          return this;
        }
        
        public bool HasLocalIdentityPublic {
          get { return result.hasLocalIdentityPublic; }
        }
        public pb::ByteString LocalIdentityPublic {
          get { return result.LocalIdentityPublic; }
          set { SetLocalIdentityPublic(value); }
        }
        public Builder SetLocalIdentityPublic(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasLocalIdentityPublic = true;
          result.localIdentityPublic_ = value;
          return this;
        }
        public Builder ClearLocalIdentityPublic() {
          PrepareBuilder();
          result.hasLocalIdentityPublic = false;
          result.localIdentityPublic_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasRemoteIdentityPublic {
          get { return result.hasRemoteIdentityPublic; }
        }
        public pb::ByteString RemoteIdentityPublic {
          get { return result.RemoteIdentityPublic; }
          set { SetRemoteIdentityPublic(value); }
        }
        public Builder SetRemoteIdentityPublic(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRemoteIdentityPublic = true;
          result.remoteIdentityPublic_ = value;
          return this;
        }
        public Builder ClearRemoteIdentityPublic() {
          PrepareBuilder();
          result.hasRemoteIdentityPublic = false;
          result.remoteIdentityPublic_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasRootKey {
          get { return result.hasRootKey; }
        }
        public pb::ByteString RootKey {
          get { return result.RootKey; }
          set { SetRootKey(value); }
        }
        public Builder SetRootKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRootKey = true;
          result.rootKey_ = value;
          return this;
        }
        public Builder ClearRootKey() {
          PrepareBuilder();
          result.hasRootKey = false;
          result.rootKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasPreviousCounter {
          get { return result.hasPreviousCounter; }
        }
        [global::System.CLSCompliant(false)]
        public uint PreviousCounter {
          get { return result.PreviousCounter; }
          set { SetPreviousCounter(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetPreviousCounter(uint value) {
          PrepareBuilder();
          result.hasPreviousCounter = true;
          result.previousCounter_ = value;
          return this;
        }
        public Builder ClearPreviousCounter() {
          PrepareBuilder();
          result.hasPreviousCounter = false;
          result.previousCounter_ = 0;
          return this;
        }
        
        public bool HasSenderChain {
         get { return result.hasSenderChain; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain SenderChain {
          get { return result.SenderChain; }
          set { SetSenderChain(value); }
        }
        public Builder SetSenderChain(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasSenderChain = true;
          result.senderChain_ = value;
          return this;
        }
        public Builder SetSenderChain(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasSenderChain = true;
          result.senderChain_ = builderForValue.Build();
          return this;
        }
        public Builder MergeSenderChain(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasSenderChain &&
              result.senderChain_ != global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.DefaultInstance) {
              result.senderChain_ = global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.CreateBuilder(result.senderChain_).MergeFrom(value).BuildPartial();
          } else {
            result.senderChain_ = value;
          }
          result.hasSenderChain = true;
          return this;
        }
        public Builder ClearSenderChain() {
          PrepareBuilder();
          result.hasSenderChain = false;
          result.senderChain_ = null;
          return this;
        }
        
        public pbc::IPopsicleList<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain> ReceiverChainsList {
          get { return PrepareBuilder().receiverChains_; }
        }
        public int ReceiverChainsCount {
          get { return result.ReceiverChainsCount; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure.Types.Chain GetReceiverChains(int index) {
          return result.GetReceiverChains(index);
        }
        public Builder SetReceiverChains(int index, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.receiverChains_[index] = value;
          return this;
        }
        public Builder SetReceiverChains(int index, global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.receiverChains_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddReceiverChains(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.receiverChains_.Add(value);
          return this;
        }
        public Builder AddReceiverChains(global::libsignal.state.StorageProtos.SessionStructure.Types.Chain.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.receiverChains_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeReceiverChains(scg::IEnumerable<global::libsignal.state.StorageProtos.SessionStructure.Types.Chain> values) {
          PrepareBuilder();
          result.receiverChains_.Add(values);
          return this;
        }
        public Builder ClearReceiverChains() {
          PrepareBuilder();
          result.receiverChains_.Clear();
          return this;
        }
        
        public bool HasPendingKeyExchange {
         get { return result.hasPendingKeyExchange; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange PendingKeyExchange {
          get { return result.PendingKeyExchange; }
          set { SetPendingKeyExchange(value); }
        }
        public Builder SetPendingKeyExchange(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPendingKeyExchange = true;
          result.pendingKeyExchange_ = value;
          return this;
        }
        public Builder SetPendingKeyExchange(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasPendingKeyExchange = true;
          result.pendingKeyExchange_ = builderForValue.Build();
          return this;
        }
        public Builder MergePendingKeyExchange(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasPendingKeyExchange &&
              result.pendingKeyExchange_ != global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.DefaultInstance) {
              result.pendingKeyExchange_ = global::libsignal.state.StorageProtos.SessionStructure.Types.PendingKeyExchange.CreateBuilder(result.pendingKeyExchange_).MergeFrom(value).BuildPartial();
          } else {
            result.pendingKeyExchange_ = value;
          }
          result.hasPendingKeyExchange = true;
          return this;
        }
        public Builder ClearPendingKeyExchange() {
          PrepareBuilder();
          result.hasPendingKeyExchange = false;
          result.pendingKeyExchange_ = null;
          return this;
        }
        
        public bool HasPendingPreKey {
         get { return result.hasPendingPreKey; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey PendingPreKey {
          get { return result.PendingPreKey; }
          set { SetPendingPreKey(value); }
        }
        public Builder SetPendingPreKey(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPendingPreKey = true;
          result.pendingPreKey_ = value;
          return this;
        }
        public Builder SetPendingPreKey(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasPendingPreKey = true;
          result.pendingPreKey_ = builderForValue.Build();
          return this;
        }
        public Builder MergePendingPreKey(global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasPendingPreKey &&
              result.pendingPreKey_ != global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.DefaultInstance) {
              result.pendingPreKey_ = global::libsignal.state.StorageProtos.SessionStructure.Types.PendingPreKey.CreateBuilder(result.pendingPreKey_).MergeFrom(value).BuildPartial();
          } else {
            result.pendingPreKey_ = value;
          }
          result.hasPendingPreKey = true;
          return this;
        }
        public Builder ClearPendingPreKey() {
          PrepareBuilder();
          result.hasPendingPreKey = false;
          result.pendingPreKey_ = null;
          return this;
        }
        
        public bool HasRemoteRegistrationId {
          get { return result.hasRemoteRegistrationId; }
        }
        [global::System.CLSCompliant(false)]
        public uint RemoteRegistrationId {
          get { return result.RemoteRegistrationId; }
          set { SetRemoteRegistrationId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetRemoteRegistrationId(uint value) {
          PrepareBuilder();
          result.hasRemoteRegistrationId = true;
          result.remoteRegistrationId_ = value;
          return this;
        }
        public Builder ClearRemoteRegistrationId() {
          PrepareBuilder();
          result.hasRemoteRegistrationId = false;
          result.remoteRegistrationId_ = 0;
          return this;
        }
        
        public bool HasLocalRegistrationId {
          get { return result.hasLocalRegistrationId; }
        }
        [global::System.CLSCompliant(false)]
        public uint LocalRegistrationId {
          get { return result.LocalRegistrationId; }
          set { SetLocalRegistrationId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetLocalRegistrationId(uint value) {
          PrepareBuilder();
          result.hasLocalRegistrationId = true;
          result.localRegistrationId_ = value;
          return this;
        }
        public Builder ClearLocalRegistrationId() {
          PrepareBuilder();
          result.hasLocalRegistrationId = false;
          result.localRegistrationId_ = 0;
          return this;
        }
        
        public bool HasNeedsRefresh {
          get { return result.hasNeedsRefresh; }
        }
        public bool NeedsRefresh {
          get { return result.NeedsRefresh; }
          set { SetNeedsRefresh(value); }
        }
        public Builder SetNeedsRefresh(bool value) {
          PrepareBuilder();
          result.hasNeedsRefresh = true;
          result.needsRefresh_ = value;
          return this;
        }
        public Builder ClearNeedsRefresh() {
          PrepareBuilder();
          result.hasNeedsRefresh = false;
          result.needsRefresh_ = false;
          return this;
        }
        
        public bool HasAliceBaseKey {
          get { return result.hasAliceBaseKey; }
        }
        public pb::ByteString AliceBaseKey {
          get { return result.AliceBaseKey; }
          set { SetAliceBaseKey(value); }
        }
        public Builder SetAliceBaseKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasAliceBaseKey = true;
          result.aliceBaseKey_ = value;
          return this;
        }
        public Builder ClearAliceBaseKey() {
          PrepareBuilder();
          result.hasAliceBaseKey = false;
          result.aliceBaseKey_ = pb::ByteString.Empty;
          return this;
        }
      }
      static SessionStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class RecordStructure : pb::GeneratedMessage<RecordStructure, RecordStructure.Builder> {
      private RecordStructure() { }
      private static readonly RecordStructure defaultInstance = new RecordStructure().MakeReadOnly();
      private static readonly string[] _recordStructureFieldNames = new string[] { "currentSession", "previousSessions" };
      private static readonly uint[] _recordStructureFieldTags = new uint[] { 10, 18 };
      public static RecordStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override RecordStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override RecordStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_RecordStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<RecordStructure, RecordStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_RecordStructure__FieldAccessorTable; }
      }
      
      public const int CurrentSessionFieldNumber = 1;
      private bool hasCurrentSession;
      private global::libsignal.state.StorageProtos.SessionStructure currentSession_;
      public bool HasCurrentSession {
        get { return hasCurrentSession; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure CurrentSession {
        get { return currentSession_ ?? global::libsignal.state.StorageProtos.SessionStructure.DefaultInstance; }
      }
      
      public const int PreviousSessionsFieldNumber = 2;
      private pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure> previousSessions_ = new pbc::PopsicleList<global::libsignal.state.StorageProtos.SessionStructure>();
      public scg::IList<global::libsignal.state.StorageProtos.SessionStructure> PreviousSessionsList {
        get { return previousSessions_; }
      }
      public int PreviousSessionsCount {
        get { return previousSessions_.Count; }
      }
      public global::libsignal.state.StorageProtos.SessionStructure GetPreviousSessions(int index) {
        return previousSessions_[index];
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _recordStructureFieldNames;
        if (hasCurrentSession) {
          output.WriteMessage(1, field_names[0], CurrentSession);
        }
        if (previousSessions_.Count > 0) {
          output.WriteMessageArray(2, field_names[1], previousSessions_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrentSession) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, CurrentSession);
        }
        foreach (global::libsignal.state.StorageProtos.SessionStructure element in PreviousSessionsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static RecordStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static RecordStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static RecordStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static RecordStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static RecordStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static RecordStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static RecordStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static RecordStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static RecordStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static RecordStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private RecordStructure MakeReadOnly() {
        previousSessions_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(RecordStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<RecordStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(RecordStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private RecordStructure result;
        
        private RecordStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            RecordStructure original = result;
            result = new RecordStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override RecordStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.RecordStructure.Descriptor; }
        }
        
        public override RecordStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.RecordStructure.DefaultInstance; }
        }
        
        public override RecordStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is RecordStructure) {
            return MergeFrom((RecordStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(RecordStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasCurrentSession) {
            MergeCurrentSession(other.CurrentSession);
          }
          if (other.previousSessions_.Count != 0) {
            result.previousSessions_.Add(other.previousSessions_);
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_recordStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _recordStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                global::libsignal.state.StorageProtos.SessionStructure.Builder subBuilder = global::libsignal.state.StorageProtos.SessionStructure.CreateBuilder();
                if (result.hasCurrentSession) {
                  subBuilder.MergeFrom(CurrentSession);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                CurrentSession = subBuilder.BuildPartial();
                break;
              }
              case 18: {
                input.ReadMessageArray(tag, field_name, result.previousSessions_, global::libsignal.state.StorageProtos.SessionStructure.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasCurrentSession {
         get { return result.hasCurrentSession; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure CurrentSession {
          get { return result.CurrentSession; }
          set { SetCurrentSession(value); }
        }
        public Builder SetCurrentSession(global::libsignal.state.StorageProtos.SessionStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasCurrentSession = true;
          result.currentSession_ = value;
          return this;
        }
        public Builder SetCurrentSession(global::libsignal.state.StorageProtos.SessionStructure.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasCurrentSession = true;
          result.currentSession_ = builderForValue.Build();
          return this;
        }
        public Builder MergeCurrentSession(global::libsignal.state.StorageProtos.SessionStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasCurrentSession &&
              result.currentSession_ != global::libsignal.state.StorageProtos.SessionStructure.DefaultInstance) {
              result.currentSession_ = global::libsignal.state.StorageProtos.SessionStructure.CreateBuilder(result.currentSession_).MergeFrom(value).BuildPartial();
          } else {
            result.currentSession_ = value;
          }
          result.hasCurrentSession = true;
          return this;
        }
        public Builder ClearCurrentSession() {
          PrepareBuilder();
          result.hasCurrentSession = false;
          result.currentSession_ = null;
          return this;
        }
        
        public pbc::IPopsicleList<global::libsignal.state.StorageProtos.SessionStructure> PreviousSessionsList {
          get { return PrepareBuilder().previousSessions_; }
        }
        public int PreviousSessionsCount {
          get { return result.PreviousSessionsCount; }
        }
        public global::libsignal.state.StorageProtos.SessionStructure GetPreviousSessions(int index) {
          return result.GetPreviousSessions(index);
        }
        public Builder SetPreviousSessions(int index, global::libsignal.state.StorageProtos.SessionStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.previousSessions_[index] = value;
          return this;
        }
        public Builder SetPreviousSessions(int index, global::libsignal.state.StorageProtos.SessionStructure.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.previousSessions_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddPreviousSessions(global::libsignal.state.StorageProtos.SessionStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.previousSessions_.Add(value);
          return this;
        }
        public Builder AddPreviousSessions(global::libsignal.state.StorageProtos.SessionStructure.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.previousSessions_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangePreviousSessions(scg::IEnumerable<global::libsignal.state.StorageProtos.SessionStructure> values) {
          PrepareBuilder();
          result.previousSessions_.Add(values);
          return this;
        }
        public Builder ClearPreviousSessions() {
          PrepareBuilder();
          result.previousSessions_.Clear();
          return this;
        }
      }
      static RecordStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class PreKeyRecordStructure : pb::GeneratedMessage<PreKeyRecordStructure, PreKeyRecordStructure.Builder> {
      private PreKeyRecordStructure() { }
      private static readonly PreKeyRecordStructure defaultInstance = new PreKeyRecordStructure().MakeReadOnly();
      private static readonly string[] _preKeyRecordStructureFieldNames = new string[] { "id", "privateKey", "publicKey" };
      private static readonly uint[] _preKeyRecordStructureFieldTags = new uint[] { 8, 26, 18 };
      public static PreKeyRecordStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override PreKeyRecordStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override PreKeyRecordStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_PreKeyRecordStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<PreKeyRecordStructure, PreKeyRecordStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_PreKeyRecordStructure__FieldAccessorTable; }
      }
      
      public const int IdFieldNumber = 1;
      private bool hasId;
      private uint id_;
      public bool HasId {
        get { return hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return id_; }
      }
      
      public const int PublicKeyFieldNumber = 2;
      private bool hasPublicKey;
      private pb::ByteString publicKey_ = pb::ByteString.Empty;
      public bool HasPublicKey {
        get { return hasPublicKey; }
      }
      public pb::ByteString PublicKey {
        get { return publicKey_; }
      }
      
      public const int PrivateKeyFieldNumber = 3;
      private bool hasPrivateKey;
      private pb::ByteString privateKey_ = pb::ByteString.Empty;
      public bool HasPrivateKey {
        get { return hasPrivateKey; }
      }
      public pb::ByteString PrivateKey {
        get { return privateKey_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _preKeyRecordStructureFieldNames;
        if (hasId) {
          output.WriteUInt32(1, field_names[0], Id);
        }
        if (hasPublicKey) {
          output.WriteBytes(2, field_names[2], PublicKey);
        }
        if (hasPrivateKey) {
          output.WriteBytes(3, field_names[1], PrivateKey);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasPublicKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, PublicKey);
        }
        if (hasPrivateKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, PrivateKey);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static PreKeyRecordStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static PreKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static PreKeyRecordStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private PreKeyRecordStructure MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(PreKeyRecordStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<PreKeyRecordStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(PreKeyRecordStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private PreKeyRecordStructure result;
        
        private PreKeyRecordStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            PreKeyRecordStructure original = result;
            result = new PreKeyRecordStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override PreKeyRecordStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.PreKeyRecordStructure.Descriptor; }
        }
        
        public override PreKeyRecordStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.PreKeyRecordStructure.DefaultInstance; }
        }
        
        public override PreKeyRecordStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is PreKeyRecordStructure) {
            return MergeFrom((PreKeyRecordStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(PreKeyRecordStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasPublicKey) {
            PublicKey = other.PublicKey;
          }
          if (other.HasPrivateKey) {
            PrivateKey = other.PrivateKey;
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_preKeyRecordStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _preKeyRecordStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasId = input.ReadUInt32(ref result.id_);
                break;
              }
              case 18: {
                result.hasPublicKey = input.ReadBytes(ref result.publicKey_);
                break;
              }
              case 26: {
                result.hasPrivateKey = input.ReadBytes(ref result.privateKey_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasId {
          get { return result.hasId; }
        }
        [global::System.CLSCompliant(false)]
        public uint Id {
          get { return result.Id; }
          set { SetId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetId(uint value) {
          PrepareBuilder();
          result.hasId = true;
          result.id_ = value;
          return this;
        }
        public Builder ClearId() {
          PrepareBuilder();
          result.hasId = false;
          result.id_ = 0;
          return this;
        }
        
        public bool HasPublicKey {
          get { return result.hasPublicKey; }
        }
        public pb::ByteString PublicKey {
          get { return result.PublicKey; }
          set { SetPublicKey(value); }
        }
        public Builder SetPublicKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPublicKey = true;
          result.publicKey_ = value;
          return this;
        }
        public Builder ClearPublicKey() {
          PrepareBuilder();
          result.hasPublicKey = false;
          result.publicKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasPrivateKey {
          get { return result.hasPrivateKey; }
        }
        public pb::ByteString PrivateKey {
          get { return result.PrivateKey; }
          set { SetPrivateKey(value); }
        }
        public Builder SetPrivateKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPrivateKey = true;
          result.privateKey_ = value;
          return this;
        }
        public Builder ClearPrivateKey() {
          PrepareBuilder();
          result.hasPrivateKey = false;
          result.privateKey_ = pb::ByteString.Empty;
          return this;
        }
      }
      static PreKeyRecordStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SignedPreKeyRecordStructure : pb::GeneratedMessage<SignedPreKeyRecordStructure, SignedPreKeyRecordStructure.Builder> {
      private SignedPreKeyRecordStructure() { }
      private static readonly SignedPreKeyRecordStructure defaultInstance = new SignedPreKeyRecordStructure().MakeReadOnly();
      private static readonly string[] _signedPreKeyRecordStructureFieldNames = new string[] { "id", "privateKey", "publicKey", "signature", "timestamp" };
      private static readonly uint[] _signedPreKeyRecordStructureFieldTags = new uint[] { 8, 26, 18, 34, 41 };
      public static SignedPreKeyRecordStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SignedPreKeyRecordStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SignedPreKeyRecordStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SignedPreKeyRecordStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SignedPreKeyRecordStructure, SignedPreKeyRecordStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SignedPreKeyRecordStructure__FieldAccessorTable; }
      }
      
      public const int IdFieldNumber = 1;
      private bool hasId;
      private uint id_;
      public bool HasId {
        get { return hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return id_; }
      }
      
      public const int PublicKeyFieldNumber = 2;
      private bool hasPublicKey;
      private pb::ByteString publicKey_ = pb::ByteString.Empty;
      public bool HasPublicKey {
        get { return hasPublicKey; }
      }
      public pb::ByteString PublicKey {
        get { return publicKey_; }
      }
      
      public const int PrivateKeyFieldNumber = 3;
      private bool hasPrivateKey;
      private pb::ByteString privateKey_ = pb::ByteString.Empty;
      public bool HasPrivateKey {
        get { return hasPrivateKey; }
      }
      public pb::ByteString PrivateKey {
        get { return privateKey_; }
      }
      
      public const int SignatureFieldNumber = 4;
      private bool hasSignature;
      private pb::ByteString signature_ = pb::ByteString.Empty;
      public bool HasSignature {
        get { return hasSignature; }
      }
      public pb::ByteString Signature {
        get { return signature_; }
      }
      
      public const int TimestampFieldNumber = 5;
      private bool hasTimestamp;
      private ulong timestamp_;
      public bool HasTimestamp {
        get { return hasTimestamp; }
      }
      [global::System.CLSCompliant(false)]
      public ulong Timestamp {
        get { return timestamp_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _signedPreKeyRecordStructureFieldNames;
        if (hasId) {
          output.WriteUInt32(1, field_names[0], Id);
        }
        if (hasPublicKey) {
          output.WriteBytes(2, field_names[2], PublicKey);
        }
        if (hasPrivateKey) {
          output.WriteBytes(3, field_names[1], PrivateKey);
        }
        if (hasSignature) {
          output.WriteBytes(4, field_names[3], Signature);
        }
        if (hasTimestamp) {
          output.WriteFixed64(5, field_names[4], Timestamp);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasPublicKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, PublicKey);
        }
        if (hasPrivateKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, PrivateKey);
        }
        if (hasSignature) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, Signature);
        }
        if (hasTimestamp) {
          size += pb::CodedOutputStream.ComputeFixed64Size(5, Timestamp);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SignedPreKeyRecordStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SignedPreKeyRecordStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SignedPreKeyRecordStructure MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SignedPreKeyRecordStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SignedPreKeyRecordStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SignedPreKeyRecordStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SignedPreKeyRecordStructure result;
        
        private SignedPreKeyRecordStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            SignedPreKeyRecordStructure original = result;
            result = new SignedPreKeyRecordStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SignedPreKeyRecordStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure.Descriptor; }
        }
        
        public override SignedPreKeyRecordStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.SignedPreKeyRecordStructure.DefaultInstance; }
        }
        
        public override SignedPreKeyRecordStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SignedPreKeyRecordStructure) {
            return MergeFrom((SignedPreKeyRecordStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SignedPreKeyRecordStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasPublicKey) {
            PublicKey = other.PublicKey;
          }
          if (other.HasPrivateKey) {
            PrivateKey = other.PrivateKey;
          }
          if (other.HasSignature) {
            Signature = other.Signature;
          }
          if (other.HasTimestamp) {
            Timestamp = other.Timestamp;
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_signedPreKeyRecordStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _signedPreKeyRecordStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasId = input.ReadUInt32(ref result.id_);
                break;
              }
              case 18: {
                result.hasPublicKey = input.ReadBytes(ref result.publicKey_);
                break;
              }
              case 26: {
                result.hasPrivateKey = input.ReadBytes(ref result.privateKey_);
                break;
              }
              case 34: {
                result.hasSignature = input.ReadBytes(ref result.signature_);
                break;
              }
              case 41: {
                result.hasTimestamp = input.ReadFixed64(ref result.timestamp_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasId {
          get { return result.hasId; }
        }
        [global::System.CLSCompliant(false)]
        public uint Id {
          get { return result.Id; }
          set { SetId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetId(uint value) {
          PrepareBuilder();
          result.hasId = true;
          result.id_ = value;
          return this;
        }
        public Builder ClearId() {
          PrepareBuilder();
          result.hasId = false;
          result.id_ = 0;
          return this;
        }
        
        public bool HasPublicKey {
          get { return result.hasPublicKey; }
        }
        public pb::ByteString PublicKey {
          get { return result.PublicKey; }
          set { SetPublicKey(value); }
        }
        public Builder SetPublicKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPublicKey = true;
          result.publicKey_ = value;
          return this;
        }
        public Builder ClearPublicKey() {
          PrepareBuilder();
          result.hasPublicKey = false;
          result.publicKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasPrivateKey {
          get { return result.hasPrivateKey; }
        }
        public pb::ByteString PrivateKey {
          get { return result.PrivateKey; }
          set { SetPrivateKey(value); }
        }
        public Builder SetPrivateKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPrivateKey = true;
          result.privateKey_ = value;
          return this;
        }
        public Builder ClearPrivateKey() {
          PrepareBuilder();
          result.hasPrivateKey = false;
          result.privateKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasSignature {
          get { return result.hasSignature; }
        }
        public pb::ByteString Signature {
          get { return result.Signature; }
          set { SetSignature(value); }
        }
        public Builder SetSignature(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasSignature = true;
          result.signature_ = value;
          return this;
        }
        public Builder ClearSignature() {
          PrepareBuilder();
          result.hasSignature = false;
          result.signature_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasTimestamp {
          get { return result.hasTimestamp; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Timestamp {
          get { return result.Timestamp; }
          set { SetTimestamp(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetTimestamp(ulong value) {
          PrepareBuilder();
          result.hasTimestamp = true;
          result.timestamp_ = value;
          return this;
        }
        public Builder ClearTimestamp() {
          PrepareBuilder();
          result.hasTimestamp = false;
          result.timestamp_ = 0;
          return this;
        }
      }
      static SignedPreKeyRecordStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class IdentityKeyPairStructure : pb::GeneratedMessage<IdentityKeyPairStructure, IdentityKeyPairStructure.Builder> {
      private IdentityKeyPairStructure() { }
      private static readonly IdentityKeyPairStructure defaultInstance = new IdentityKeyPairStructure().MakeReadOnly();
      private static readonly string[] _identityKeyPairStructureFieldNames = new string[] { "privateKey", "publicKey" };
      private static readonly uint[] _identityKeyPairStructureFieldTags = new uint[] { 18, 10 };
      public static IdentityKeyPairStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override IdentityKeyPairStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override IdentityKeyPairStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_IdentityKeyPairStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<IdentityKeyPairStructure, IdentityKeyPairStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_IdentityKeyPairStructure__FieldAccessorTable; }
      }
      
      public const int PublicKeyFieldNumber = 1;
      private bool hasPublicKey;
      private pb::ByteString publicKey_ = pb::ByteString.Empty;
      public bool HasPublicKey {
        get { return hasPublicKey; }
      }
      public pb::ByteString PublicKey {
        get { return publicKey_; }
      }
      
      public const int PrivateKeyFieldNumber = 2;
      private bool hasPrivateKey;
      private pb::ByteString privateKey_ = pb::ByteString.Empty;
      public bool HasPrivateKey {
        get { return hasPrivateKey; }
      }
      public pb::ByteString PrivateKey {
        get { return privateKey_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _identityKeyPairStructureFieldNames;
        if (hasPublicKey) {
          output.WriteBytes(1, field_names[1], PublicKey);
        }
        if (hasPrivateKey) {
          output.WriteBytes(2, field_names[0], PrivateKey);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPublicKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(1, PublicKey);
        }
        if (hasPrivateKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, PrivateKey);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static IdentityKeyPairStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static IdentityKeyPairStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private IdentityKeyPairStructure MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(IdentityKeyPairStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<IdentityKeyPairStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(IdentityKeyPairStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private IdentityKeyPairStructure result;
        
        private IdentityKeyPairStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            IdentityKeyPairStructure original = result;
            result = new IdentityKeyPairStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override IdentityKeyPairStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.IdentityKeyPairStructure.Descriptor; }
        }
        
        public override IdentityKeyPairStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.IdentityKeyPairStructure.DefaultInstance; }
        }
        
        public override IdentityKeyPairStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is IdentityKeyPairStructure) {
            return MergeFrom((IdentityKeyPairStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(IdentityKeyPairStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasPublicKey) {
            PublicKey = other.PublicKey;
          }
          if (other.HasPrivateKey) {
            PrivateKey = other.PrivateKey;
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_identityKeyPairStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _identityKeyPairStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasPublicKey = input.ReadBytes(ref result.publicKey_);
                break;
              }
              case 18: {
                result.hasPrivateKey = input.ReadBytes(ref result.privateKey_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasPublicKey {
          get { return result.hasPublicKey; }
        }
        public pb::ByteString PublicKey {
          get { return result.PublicKey; }
          set { SetPublicKey(value); }
        }
        public Builder SetPublicKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPublicKey = true;
          result.publicKey_ = value;
          return this;
        }
        public Builder ClearPublicKey() {
          PrepareBuilder();
          result.hasPublicKey = false;
          result.publicKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasPrivateKey {
          get { return result.hasPrivateKey; }
        }
        public pb::ByteString PrivateKey {
          get { return result.PrivateKey; }
          set { SetPrivateKey(value); }
        }
        public Builder SetPrivateKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasPrivateKey = true;
          result.privateKey_ = value;
          return this;
        }
        public Builder ClearPrivateKey() {
          PrepareBuilder();
          result.hasPrivateKey = false;
          result.privateKey_ = pb::ByteString.Empty;
          return this;
        }
      }
      static IdentityKeyPairStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SenderKeyStateStructure : pb::GeneratedMessage<SenderKeyStateStructure, SenderKeyStateStructure.Builder> {
      private SenderKeyStateStructure() { }
      private static readonly SenderKeyStateStructure defaultInstance = new SenderKeyStateStructure().MakeReadOnly();
      private static readonly string[] _senderKeyStateStructureFieldNames = new string[] { "senderChainKey", "senderKeyId", "senderMessageKeys", "senderSigningKey" };
      private static readonly uint[] _senderKeyStateStructureFieldTags = new uint[] { 18, 8, 34, 26 };
      public static SenderKeyStateStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SenderKeyStateStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SenderKeyStateStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SenderKeyStateStructure, SenderKeyStateStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class SenderChainKey : pb::GeneratedMessage<SenderChainKey, SenderChainKey.Builder> {
          private SenderChainKey() { }
          private static readonly SenderChainKey defaultInstance = new SenderChainKey().MakeReadOnly();
          private static readonly string[] _senderChainKeyFieldNames = new string[] { "iteration", "seed" };
          private static readonly uint[] _senderChainKeyFieldTags = new uint[] { 8, 18 };
          public static SenderChainKey DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override SenderChainKey DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override SenderChainKey ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<SenderChainKey, SenderChainKey.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderChainKey__FieldAccessorTable; }
          }
          
          public const int IterationFieldNumber = 1;
          private bool hasIteration;
          private uint iteration_;
          public bool HasIteration {
            get { return hasIteration; }
          }
          [global::System.CLSCompliant(false)]
          public uint Iteration {
            get { return iteration_; }
          }
          
          public const int SeedFieldNumber = 2;
          private bool hasSeed;
          private pb::ByteString seed_ = pb::ByteString.Empty;
          public bool HasSeed {
            get { return hasSeed; }
          }
          public pb::ByteString Seed {
            get { return seed_; }
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _senderChainKeyFieldNames;
            if (hasIteration) {
              output.WriteUInt32(1, field_names[0], Iteration);
            }
            if (hasSeed) {
              output.WriteBytes(2, field_names[1], Seed);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasIteration) {
              size += pb::CodedOutputStream.ComputeUInt32Size(1, Iteration);
            }
            if (hasSeed) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, Seed);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static SenderChainKey ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static SenderChainKey ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static SenderChainKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static SenderChainKey ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderChainKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private SenderChainKey MakeReadOnly() {
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(SenderChainKey prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<SenderChainKey, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(SenderChainKey cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private SenderChainKey result;
            
            private SenderChainKey PrepareBuilder() {
              if (resultIsReadOnly) {
                SenderChainKey original = result;
                result = new SenderChainKey();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override SenderChainKey MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.Descriptor; }
            }
            
            public override SenderChainKey DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.DefaultInstance; }
            }
            
            public override SenderChainKey BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is SenderChainKey) {
                return MergeFrom((SenderChainKey) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(SenderChainKey other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasIteration) {
                Iteration = other.Iteration;
              }
              if (other.HasSeed) {
                Seed = other.Seed;
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_senderChainKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _senderChainKeyFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 8: {
                    result.hasIteration = input.ReadUInt32(ref result.iteration_);
                    break;
                  }
                  case 18: {
                    result.hasSeed = input.ReadBytes(ref result.seed_);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasIteration {
              get { return result.hasIteration; }
            }
            [global::System.CLSCompliant(false)]
            public uint Iteration {
              get { return result.Iteration; }
              set { SetIteration(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetIteration(uint value) {
              PrepareBuilder();
              result.hasIteration = true;
              result.iteration_ = value;
              return this;
            }
            public Builder ClearIteration() {
              PrepareBuilder();
              result.hasIteration = false;
              result.iteration_ = 0;
              return this;
            }
            
            public bool HasSeed {
              get { return result.hasSeed; }
            }
            public pb::ByteString Seed {
              get { return result.Seed; }
              set { SetSeed(value); }
            }
            public Builder SetSeed(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasSeed = true;
              result.seed_ = value;
              return this;
            }
            public Builder ClearSeed() {
              PrepareBuilder();
              result.hasSeed = false;
              result.seed_ = pb::ByteString.Empty;
              return this;
            }
          }
          static SenderChainKey() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class SenderMessageKey : pb::GeneratedMessage<SenderMessageKey, SenderMessageKey.Builder> {
          private SenderMessageKey() { }
          private static readonly SenderMessageKey defaultInstance = new SenderMessageKey().MakeReadOnly();
          private static readonly string[] _senderMessageKeyFieldNames = new string[] { "iteration", "seed" };
          private static readonly uint[] _senderMessageKeyFieldTags = new uint[] { 8, 18 };
          public static SenderMessageKey DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override SenderMessageKey DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override SenderMessageKey ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<SenderMessageKey, SenderMessageKey.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderMessageKey__FieldAccessorTable; }
          }
          
          public const int IterationFieldNumber = 1;
          private bool hasIteration;
          private uint iteration_;
          public bool HasIteration {
            get { return hasIteration; }
          }
          [global::System.CLSCompliant(false)]
          public uint Iteration {
            get { return iteration_; }
          }
          
          public const int SeedFieldNumber = 2;
          private bool hasSeed;
          private pb::ByteString seed_ = pb::ByteString.Empty;
          public bool HasSeed {
            get { return hasSeed; }
          }
          public pb::ByteString Seed {
            get { return seed_; }
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _senderMessageKeyFieldNames;
            if (hasIteration) {
              output.WriteUInt32(1, field_names[0], Iteration);
            }
            if (hasSeed) {
              output.WriteBytes(2, field_names[1], Seed);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasIteration) {
              size += pb::CodedOutputStream.ComputeUInt32Size(1, Iteration);
            }
            if (hasSeed) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, Seed);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static SenderMessageKey ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static SenderMessageKey ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static SenderMessageKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderMessageKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private SenderMessageKey MakeReadOnly() {
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(SenderMessageKey prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<SenderMessageKey, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(SenderMessageKey cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private SenderMessageKey result;
            
            private SenderMessageKey PrepareBuilder() {
              if (resultIsReadOnly) {
                SenderMessageKey original = result;
                result = new SenderMessageKey();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override SenderMessageKey MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.Descriptor; }
            }
            
            public override SenderMessageKey DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.DefaultInstance; }
            }
            
            public override SenderMessageKey BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is SenderMessageKey) {
                return MergeFrom((SenderMessageKey) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(SenderMessageKey other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasIteration) {
                Iteration = other.Iteration;
              }
              if (other.HasSeed) {
                Seed = other.Seed;
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_senderMessageKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _senderMessageKeyFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 8: {
                    result.hasIteration = input.ReadUInt32(ref result.iteration_);
                    break;
                  }
                  case 18: {
                    result.hasSeed = input.ReadBytes(ref result.seed_);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasIteration {
              get { return result.hasIteration; }
            }
            [global::System.CLSCompliant(false)]
            public uint Iteration {
              get { return result.Iteration; }
              set { SetIteration(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetIteration(uint value) {
              PrepareBuilder();
              result.hasIteration = true;
              result.iteration_ = value;
              return this;
            }
            public Builder ClearIteration() {
              PrepareBuilder();
              result.hasIteration = false;
              result.iteration_ = 0;
              return this;
            }
            
            public bool HasSeed {
              get { return result.hasSeed; }
            }
            public pb::ByteString Seed {
              get { return result.Seed; }
              set { SetSeed(value); }
            }
            public Builder SetSeed(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasSeed = true;
              result.seed_ = value;
              return this;
            }
            public Builder ClearSeed() {
              PrepareBuilder();
              result.hasSeed = false;
              result.seed_ = pb::ByteString.Empty;
              return this;
            }
          }
          static SenderMessageKey() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class SenderSigningKey : pb::GeneratedMessage<SenderSigningKey, SenderSigningKey.Builder> {
          private SenderSigningKey() { }
          private static readonly SenderSigningKey defaultInstance = new SenderSigningKey().MakeReadOnly();
          private static readonly string[] _senderSigningKeyFieldNames = new string[] { "private", "public" };
          private static readonly uint[] _senderSigningKeyFieldTags = new uint[] { 18, 10 };
          public static SenderSigningKey DefaultInstance {
            get { return defaultInstance; }
          }
          
          public override SenderSigningKey DefaultInstanceForType {
            get { return DefaultInstance; }
          }
          
          protected override SenderSigningKey ThisMessage {
            get { return this; }
          }
          
          public static pbd::MessageDescriptor Descriptor {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__Descriptor; }
          }
          
          protected override pb::FieldAccess.FieldAccessorTable<SenderSigningKey, SenderSigningKey.Builder> InternalFieldAccessors {
            get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyStateStructure_SenderSigningKey__FieldAccessorTable; }
          }
          
          public const int PublicFieldNumber = 1;
          private bool hasPublic;
          private pb::ByteString public_ = pb::ByteString.Empty;
          public bool HasPublic {
            get { return hasPublic; }
          }
          public pb::ByteString Public {
            get { return public_; }
          }
          
          public const int PrivateFieldNumber = 2;
          private bool hasPrivate;
          private pb::ByteString private_ = pb::ByteString.Empty;
          public bool HasPrivate {
            get { return hasPrivate; }
          }
          public pb::ByteString Private {
            get { return private_; }
          }
          
          public override bool IsInitialized {
            get {
              return true;
            }
          }
          
          public override void WriteTo(pb::ICodedOutputStream output) {
            CalcSerializedSize();
            string[] field_names = _senderSigningKeyFieldNames;
            if (hasPublic) {
              output.WriteBytes(1, field_names[1], Public);
            }
            if (hasPrivate) {
              output.WriteBytes(2, field_names[0], Private);
            }
            UnknownFields.WriteTo(output);
          }
          
          private int memoizedSerializedSize = -1;
          public override int SerializedSize {
            get {
              int size = memoizedSerializedSize;
              if (size != -1) return size;
              return CalcSerializedSize();
            }
          }
          
          private int CalcSerializedSize() {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasPublic) {
              size += pb::CodedOutputStream.ComputeBytesSize(1, Public);
            }
            if (hasPrivate) {
              size += pb::CodedOutputStream.ComputeBytesSize(2, Private);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
          public static SenderSigningKey ParseFrom(pb::ByteString data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(byte[] data) {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(global::System.IO.Stream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          public static SenderSigningKey ParseDelimitedFrom(global::System.IO.Stream input) {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
          }
          public static SenderSigningKey ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(pb::ICodedInputStream input) {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
          }
          public static SenderSigningKey ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
          }
          private SenderSigningKey MakeReadOnly() {
            return this;
          }
          
          public static Builder CreateBuilder() { return new Builder(); }
          public override Builder ToBuilder() { return CreateBuilder(this); }
          public override Builder CreateBuilderForType() { return new Builder(); }
          public static Builder CreateBuilder(SenderSigningKey prototype) {
            return new Builder(prototype);
          }
          
          [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
          public sealed partial class Builder : pb::GeneratedBuilder<SenderSigningKey, Builder> {
            protected override Builder ThisBuilder {
              get { return this; }
            }
            public Builder() {
              result = DefaultInstance;
              resultIsReadOnly = true;
            }
            internal Builder(SenderSigningKey cloneFrom) {
              result = cloneFrom;
              resultIsReadOnly = true;
            }
            
            private bool resultIsReadOnly;
            private SenderSigningKey result;
            
            private SenderSigningKey PrepareBuilder() {
              if (resultIsReadOnly) {
                SenderSigningKey original = result;
                result = new SenderSigningKey();
                resultIsReadOnly = false;
                MergeFrom(original);
              }
              return result;
            }
            
            public override bool IsInitialized {
              get { return result.IsInitialized; }
            }
            
            protected override SenderSigningKey MessageBeingBuilt {
              get { return PrepareBuilder(); }
            }
            
            public override Builder Clear() {
              result = DefaultInstance;
              resultIsReadOnly = true;
              return this;
            }
            
            public override Builder Clone() {
              if (resultIsReadOnly) {
                return new Builder(result);
              } else {
                return new Builder().MergeFrom(result);
              }
            }
            
            public override pbd::MessageDescriptor DescriptorForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.Descriptor; }
            }
            
            public override SenderSigningKey DefaultInstanceForType {
              get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.DefaultInstance; }
            }
            
            public override SenderSigningKey BuildPartial() {
              if (resultIsReadOnly) {
                return result;
              }
              resultIsReadOnly = true;
              return result.MakeReadOnly();
            }
            
            public override Builder MergeFrom(pb::IMessage other) {
              if (other is SenderSigningKey) {
                return MergeFrom((SenderSigningKey) other);
              } else {
                base.MergeFrom(other);
                return this;
              }
            }
            
            public override Builder MergeFrom(SenderSigningKey other) {
              if (other == DefaultInstance) return this;
              PrepareBuilder();
              if (other.HasPublic) {
                Public = other.Public;
              }
              if (other.HasPrivate) {
                Private = other.Private;
              }
                            MergeUnknownFields(other.UnknownFields);
              return this;
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input) {
              return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }
            
            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
              PrepareBuilder();
              pb::UnknownFieldSet.Builder unknownFields = null;
              uint tag;
              string field_name;
              while (input.ReadTag(out tag, out field_name)) {
                if(tag == 0 && field_name != null) {
                  int field_ordinal = global::System.Array.BinarySearch(_senderSigningKeyFieldNames, field_name, global::System.StringComparer.Ordinal);
                  if(field_ordinal >= 0)
                    tag = _senderSigningKeyFieldTags[field_ordinal];
                  else {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    continue;
                  }
                }
                switch (tag) {
                  case 0: {
                    throw pb::InvalidProtocolBufferException.InvalidTag();
                  }
                  default: {
                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                      if (unknownFields != null) {
                                                    UnknownFields = unknownFields.Build();
                      }
                      return this;
                    }
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                    }
                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                    break;
                  }
                  case 10: {
                    result.hasPublic = input.ReadBytes(ref result.public_);
                    break;
                  }
                  case 18: {
                    result.hasPrivate = input.ReadBytes(ref result.private_);
                    break;
                  }
                }
              }
              
              if (unknownFields != null) {
                                UnknownFields = unknownFields.Build();
              }
              return this;
            }
            
            
            public bool HasPublic {
              get { return result.hasPublic; }
            }
            public pb::ByteString Public {
              get { return result.Public; }
              set { SetPublic(value); }
            }
            public Builder SetPublic(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasPublic = true;
              result.public_ = value;
              return this;
            }
            public Builder ClearPublic() {
              PrepareBuilder();
              result.hasPublic = false;
              result.public_ = pb::ByteString.Empty;
              return this;
            }
            
            public bool HasPrivate {
              get { return result.hasPrivate; }
            }
            public pb::ByteString Private {
              get { return result.Private; }
              set { SetPrivate(value); }
            }
            public Builder SetPrivate(pb::ByteString value) {
              pb::ThrowHelper.ThrowIfNull(value, "value");
              PrepareBuilder();
              result.hasPrivate = true;
              result.private_ = value;
              return this;
            }
            public Builder ClearPrivate() {
              PrepareBuilder();
              result.hasPrivate = false;
              result.private_ = pb::ByteString.Empty;
              return this;
            }
          }
          static SenderSigningKey() {
            object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
          }
        }
        
      }
      #endregion
      
      public const int SenderKeyIdFieldNumber = 1;
      private bool hasSenderKeyId;
      private uint senderKeyId_;
      public bool HasSenderKeyId {
        get { return hasSenderKeyId; }
      }
      [global::System.CLSCompliant(false)]
      public uint SenderKeyId {
        get { return senderKeyId_; }
      }
      
      public const int SenderChainKeyFieldNumber = 2;
      private bool hasSenderChainKey;
      private global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey senderChainKey_;
      public bool HasSenderChainKey {
        get { return hasSenderChainKey; }
      }
      public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey SenderChainKey {
        get { return senderChainKey_ ?? global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.DefaultInstance; }
      }
      
      public const int SenderSigningKeyFieldNumber = 3;
      private bool hasSenderSigningKey;
      private global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey senderSigningKey_;
      public bool HasSenderSigningKey {
        get { return hasSenderSigningKey; }
      }
      public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey SenderSigningKey {
        get { return senderSigningKey_ ?? global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.DefaultInstance; }
      }
      
      public const int SenderMessageKeysFieldNumber = 4;
      private pbc::PopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey> senderMessageKeys_ = new pbc::PopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey>();
      public scg::IList<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey> SenderMessageKeysList {
        get { return senderMessageKeys_; }
      }
      public int SenderMessageKeysCount {
        get { return senderMessageKeys_.Count; }
      }
      public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey GetSenderMessageKeys(int index) {
        return senderMessageKeys_[index];
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _senderKeyStateStructureFieldNames;
        if (hasSenderKeyId) {
          output.WriteUInt32(1, field_names[1], SenderKeyId);
        }
        if (hasSenderChainKey) {
          output.WriteMessage(2, field_names[0], SenderChainKey);
        }
        if (hasSenderSigningKey) {
          output.WriteMessage(3, field_names[3], SenderSigningKey);
        }
        if (senderMessageKeys_.Count > 0) {
          output.WriteMessageArray(4, field_names[2], senderMessageKeys_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasSenderKeyId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, SenderKeyId);
        }
        if (hasSenderChainKey) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, SenderChainKey);
        }
        if (hasSenderSigningKey) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, SenderSigningKey);
        }
        foreach (global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey element in SenderMessageKeysList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SenderKeyStateStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SenderKeyStateStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyStateStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SenderKeyStateStructure MakeReadOnly() {
        senderMessageKeys_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SenderKeyStateStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SenderKeyStateStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SenderKeyStateStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SenderKeyStateStructure result;
        
        private SenderKeyStateStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            SenderKeyStateStructure original = result;
            result = new SenderKeyStateStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SenderKeyStateStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.Descriptor; }
        }
        
        public override SenderKeyStateStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.SenderKeyStateStructure.DefaultInstance; }
        }
        
        public override SenderKeyStateStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SenderKeyStateStructure) {
            return MergeFrom((SenderKeyStateStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SenderKeyStateStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasSenderKeyId) {
            SenderKeyId = other.SenderKeyId;
          }
          if (other.HasSenderChainKey) {
            MergeSenderChainKey(other.SenderChainKey);
          }
          if (other.HasSenderSigningKey) {
            MergeSenderSigningKey(other.SenderSigningKey);
          }
          if (other.senderMessageKeys_.Count != 0) {
            result.senderMessageKeys_.Add(other.senderMessageKeys_);
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_senderKeyStateStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _senderKeyStateStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasSenderKeyId = input.ReadUInt32(ref result.senderKeyId_);
                break;
              }
              case 18: {
                global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.Builder subBuilder = global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.CreateBuilder();
                if (result.hasSenderChainKey) {
                  subBuilder.MergeFrom(SenderChainKey);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                SenderChainKey = subBuilder.BuildPartial();
                break;
              }
              case 26: {
                global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.Builder subBuilder = global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.CreateBuilder();
                if (result.hasSenderSigningKey) {
                  subBuilder.MergeFrom(SenderSigningKey);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                SenderSigningKey = subBuilder.BuildPartial();
                break;
              }
              case 34: {
                input.ReadMessageArray(tag, field_name, result.senderMessageKeys_, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasSenderKeyId {
          get { return result.hasSenderKeyId; }
        }
        [global::System.CLSCompliant(false)]
        public uint SenderKeyId {
          get { return result.SenderKeyId; }
          set { SetSenderKeyId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetSenderKeyId(uint value) {
          PrepareBuilder();
          result.hasSenderKeyId = true;
          result.senderKeyId_ = value;
          return this;
        }
        public Builder ClearSenderKeyId() {
          PrepareBuilder();
          result.hasSenderKeyId = false;
          result.senderKeyId_ = 0;
          return this;
        }
        
        public bool HasSenderChainKey {
         get { return result.hasSenderChainKey; }
        }
        public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey SenderChainKey {
          get { return result.SenderChainKey; }
          set { SetSenderChainKey(value); }
        }
        public Builder SetSenderChainKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasSenderChainKey = true;
          result.senderChainKey_ = value;
          return this;
        }
        public Builder SetSenderChainKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasSenderChainKey = true;
          result.senderChainKey_ = builderForValue.Build();
          return this;
        }
        public Builder MergeSenderChainKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasSenderChainKey &&
              result.senderChainKey_ != global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.DefaultInstance) {
              result.senderChainKey_ = global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderChainKey.CreateBuilder(result.senderChainKey_).MergeFrom(value).BuildPartial();
          } else {
            result.senderChainKey_ = value;
          }
          result.hasSenderChainKey = true;
          return this;
        }
        public Builder ClearSenderChainKey() {
          PrepareBuilder();
          result.hasSenderChainKey = false;
          result.senderChainKey_ = null;
          return this;
        }
        
        public bool HasSenderSigningKey {
         get { return result.hasSenderSigningKey; }
        }
        public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey SenderSigningKey {
          get { return result.SenderSigningKey; }
          set { SetSenderSigningKey(value); }
        }
        public Builder SetSenderSigningKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasSenderSigningKey = true;
          result.senderSigningKey_ = value;
          return this;
        }
        public Builder SetSenderSigningKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasSenderSigningKey = true;
          result.senderSigningKey_ = builderForValue.Build();
          return this;
        }
        public Builder MergeSenderSigningKey(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasSenderSigningKey &&
              result.senderSigningKey_ != global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.DefaultInstance) {
              result.senderSigningKey_ = global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderSigningKey.CreateBuilder(result.senderSigningKey_).MergeFrom(value).BuildPartial();
          } else {
            result.senderSigningKey_ = value;
          }
          result.hasSenderSigningKey = true;
          return this;
        }
        public Builder ClearSenderSigningKey() {
          PrepareBuilder();
          result.hasSenderSigningKey = false;
          result.senderSigningKey_ = null;
          return this;
        }
        
        public pbc::IPopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey> SenderMessageKeysList {
          get { return PrepareBuilder().senderMessageKeys_; }
        }
        public int SenderMessageKeysCount {
          get { return result.SenderMessageKeysCount; }
        }
        public global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey GetSenderMessageKeys(int index) {
          return result.GetSenderMessageKeys(index);
        }
        public Builder SetSenderMessageKeys(int index, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.senderMessageKeys_[index] = value;
          return this;
        }
        public Builder SetSenderMessageKeys(int index, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.senderMessageKeys_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddSenderMessageKeys(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.senderMessageKeys_.Add(value);
          return this;
        }
        public Builder AddSenderMessageKeys(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.senderMessageKeys_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeSenderMessageKeys(scg::IEnumerable<global::libsignal.state.StorageProtos.SenderKeyStateStructure.Types.SenderMessageKey> values) {
          PrepareBuilder();
          result.senderMessageKeys_.Add(values);
          return this;
        }
        public Builder ClearSenderMessageKeys() {
          PrepareBuilder();
          result.senderMessageKeys_.Clear();
          return this;
        }
      }
      static SenderKeyStateStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SenderKeyRecordStructure : pb::GeneratedMessage<SenderKeyRecordStructure, SenderKeyRecordStructure.Builder> {
      private SenderKeyRecordStructure() { }
      private static readonly SenderKeyRecordStructure defaultInstance = new SenderKeyRecordStructure().MakeReadOnly();
      private static readonly string[] _senderKeyRecordStructureFieldNames = new string[] { "senderKeyStates" };
      private static readonly uint[] _senderKeyRecordStructureFieldTags = new uint[] { 10 };
      public static SenderKeyRecordStructure DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SenderKeyRecordStructure DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SenderKeyRecordStructure ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyRecordStructure__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SenderKeyRecordStructure, SenderKeyRecordStructure.Builder> InternalFieldAccessors {
        get { return global::libsignal.state.StorageProtos.internal__static_textsecure_SenderKeyRecordStructure__FieldAccessorTable; }
      }
      
      public const int SenderKeyStatesFieldNumber = 1;
      private pbc::PopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure> senderKeyStates_ = new pbc::PopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure>();
      public scg::IList<global::libsignal.state.StorageProtos.SenderKeyStateStructure> SenderKeyStatesList {
        get { return senderKeyStates_; }
      }
      public int SenderKeyStatesCount {
        get { return senderKeyStates_.Count; }
      }
      public global::libsignal.state.StorageProtos.SenderKeyStateStructure GetSenderKeyStates(int index) {
        return senderKeyStates_[index];
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _senderKeyRecordStructureFieldNames;
        if (senderKeyStates_.Count > 0) {
          output.WriteMessageArray(1, field_names[0], senderKeyStates_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::libsignal.state.StorageProtos.SenderKeyStateStructure element in SenderKeyStatesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SenderKeyRecordStructure ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyRecordStructure ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SenderKeyRecordStructure MakeReadOnly() {
        senderKeyStates_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SenderKeyRecordStructure prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SenderKeyRecordStructure, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SenderKeyRecordStructure cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SenderKeyRecordStructure result;
        
        private SenderKeyRecordStructure PrepareBuilder() {
          if (resultIsReadOnly) {
            SenderKeyRecordStructure original = result;
            result = new SenderKeyRecordStructure();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SenderKeyRecordStructure MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.state.StorageProtos.SenderKeyRecordStructure.Descriptor; }
        }
        
        public override SenderKeyRecordStructure DefaultInstanceForType {
          get { return global::libsignal.state.StorageProtos.SenderKeyRecordStructure.DefaultInstance; }
        }
        
        public override SenderKeyRecordStructure BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SenderKeyRecordStructure) {
            return MergeFrom((SenderKeyRecordStructure) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SenderKeyRecordStructure other) {
          if (other == DefaultInstance) return this;
          PrepareBuilder();
          if (other.senderKeyStates_.Count != 0) {
            result.senderKeyStates_.Add(other.senderKeyStates_);
          }
                    MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_senderKeyRecordStructureFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _senderKeyRecordStructureFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                                            UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                input.ReadMessageArray(tag, field_name, result.senderKeyStates_, global::libsignal.state.StorageProtos.SenderKeyStateStructure.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
                        UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public pbc::IPopsicleList<global::libsignal.state.StorageProtos.SenderKeyStateStructure> SenderKeyStatesList {
          get { return PrepareBuilder().senderKeyStates_; }
        }
        public int SenderKeyStatesCount {
          get { return result.SenderKeyStatesCount; }
        }
        public global::libsignal.state.StorageProtos.SenderKeyStateStructure GetSenderKeyStates(int index) {
          return result.GetSenderKeyStates(index);
        }
        public Builder SetSenderKeyStates(int index, global::libsignal.state.StorageProtos.SenderKeyStateStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.senderKeyStates_[index] = value;
          return this;
        }
        public Builder SetSenderKeyStates(int index, global::libsignal.state.StorageProtos.SenderKeyStateStructure.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.senderKeyStates_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddSenderKeyStates(global::libsignal.state.StorageProtos.SenderKeyStateStructure value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.senderKeyStates_.Add(value);
          return this;
        }
        public Builder AddSenderKeyStates(global::libsignal.state.StorageProtos.SenderKeyStateStructure.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.senderKeyStates_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeSenderKeyStates(scg::IEnumerable<global::libsignal.state.StorageProtos.SenderKeyStateStructure> values) {
          PrepareBuilder();
          result.senderKeyStates_.Add(values);
          return this;
        }
        public Builder ClearSenderKeyStates() {
          PrepareBuilder();
          result.senderKeyStates_.Clear();
          return this;
        }
      }
      static SenderKeyRecordStructure() {
        object.ReferenceEquals(global::libsignal.state.StorageProtos.Descriptor, null);
      }
    }
    
    #endregion
    
  }
}

#endregion Designer generated code
