// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace libsignal.protocol {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class SignalProtos {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    private static pbd::MessageDescriptor internal__static_SignalMessage__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SignalMessage, global::libsignal.protocol.SignalProtos.SignalMessage.Builder> internal__static_SignalMessage__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_PreKeySignalMessage__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.PreKeySignalMessage, global::libsignal.protocol.SignalProtos.PreKeySignalMessage.Builder> internal__static_PreKeySignalMessage__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_KeyExchangeMessage__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.KeyExchangeMessage, global::libsignal.protocol.SignalProtos.KeyExchangeMessage.Builder> internal__static_KeyExchangeMessage__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_SenderKeyMessage__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SenderKeyMessage, global::libsignal.protocol.SignalProtos.SenderKeyMessage.Builder> internal__static_SenderKeyMessage__FieldAccessorTable;
    private static pbd::MessageDescriptor internal__static_SenderKeyDistributionMessage__Descriptor;
    private static pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage, global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage.Builder> internal__static_SenderKeyDistributionMessage__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static SignalProtos() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChlXaGlzcGVyVGV4dFByb3RvY29sLnByb3RvImEKDVNpZ25hbE1lc3NhZ2US", 
            "EgoKcmF0Y2hldEtleRgBIAEoDBIPCgdjb3VudGVyGAIgASgNEhcKD3ByZXZp", 
            "b3VzQ291bnRlchgDIAEoDRISCgpjaXBoZXJ0ZXh0GAQgASgMIo4BChNQcmVL", 
            "ZXlTaWduYWxNZXNzYWdlEhYKDnJlZ2lzdHJhdGlvbklkGAUgASgNEhAKCHBy", 
            "ZUtleUlkGAEgASgNEhYKDnNpZ25lZFByZUtleUlkGAYgASgNEg8KB2Jhc2VL", 
            "ZXkYAiABKAwSEwoLaWRlbnRpdHlLZXkYAyABKAwSDwoHbWVzc2FnZRgEIAEo", 
            "DCJ0ChJLZXlFeGNoYW5nZU1lc3NhZ2USCgoCaWQYASABKA0SDwoHYmFzZUtl", 
            "eRgCIAEoDBISCgpyYXRjaGV0S2V5GAMgASgMEhMKC2lkZW50aXR5S2V5GAQg", 
            "ASgMEhgKEGJhc2VLZXlTaWduYXR1cmUYBSABKAwiRQoQU2VuZGVyS2V5TWVz", 
            "c2FnZRIKCgJpZBgBIAEoDRIRCglpdGVyYXRpb24YAiABKA0SEgoKY2lwaGVy", 
            "dGV4dBgDIAEoDCJjChxTZW5kZXJLZXlEaXN0cmlidXRpb25NZXNzYWdlEgoK", 
            "AmlkGAEgASgNEhEKCWl0ZXJhdGlvbhgCIAEoDRIQCghjaGFpbktleRgDIAEo", 
          "DBISCgpzaWduaW5nS2V5GAQgASgM"));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_SignalMessage__Descriptor = Descriptor.MessageTypes[0];
        internal__static_SignalMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SignalMessage, global::libsignal.protocol.SignalProtos.SignalMessage.Builder>(internal__static_SignalMessage__Descriptor,
                new string[] { "RatchetKey", "Counter", "PreviousCounter", "Ciphertext", });
        internal__static_PreKeySignalMessage__Descriptor = Descriptor.MessageTypes[1];
        internal__static_PreKeySignalMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.PreKeySignalMessage, global::libsignal.protocol.SignalProtos.PreKeySignalMessage.Builder>(internal__static_PreKeySignalMessage__Descriptor,
                new string[] { "RegistrationId", "PreKeyId", "SignedPreKeyId", "BaseKey", "IdentityKey", "Message", });
        internal__static_KeyExchangeMessage__Descriptor = Descriptor.MessageTypes[2];
        internal__static_KeyExchangeMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.KeyExchangeMessage, global::libsignal.protocol.SignalProtos.KeyExchangeMessage.Builder>(internal__static_KeyExchangeMessage__Descriptor,
                new string[] { "Id", "BaseKey", "RatchetKey", "IdentityKey", "BaseKeySignature", });
        internal__static_SenderKeyMessage__Descriptor = Descriptor.MessageTypes[3];
        internal__static_SenderKeyMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SenderKeyMessage, global::libsignal.protocol.SignalProtos.SenderKeyMessage.Builder>(internal__static_SenderKeyMessage__Descriptor,
                new string[] { "Id", "Iteration", "Ciphertext", });
        internal__static_SenderKeyDistributionMessage__Descriptor = Descriptor.MessageTypes[4];
        internal__static_SenderKeyDistributionMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage, global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage.Builder>(internal__static_SenderKeyDistributionMessage__Descriptor,
                new string[] { "Id", "Iteration", "ChainKey", "SigningKey", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
    #region Messages
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SignalMessage : pb::GeneratedMessage<SignalMessage, SignalMessage.Builder> {
      private SignalMessage() { }
      private static readonly SignalMessage defaultInstance = new SignalMessage().MakeReadOnly();
      private static readonly string[] _signalMessageFieldNames = new string[] { "ciphertext", "counter", "previousCounter", "ratchetKey" };
      private static readonly uint[] _signalMessageFieldTags = new uint[] { 34, 16, 24, 10 };
      public static SignalMessage DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SignalMessage DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SignalMessage ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SignalMessage__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SignalMessage, SignalMessage.Builder> InternalFieldAccessors {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SignalMessage__FieldAccessorTable; }
      }
      
      public const int RatchetKeyFieldNumber = 1;
      private bool hasRatchetKey;
      private pb::ByteString ratchetKey_ = pb::ByteString.Empty;
      public bool HasRatchetKey {
        get { return hasRatchetKey; }
      }
      public pb::ByteString RatchetKey {
        get { return ratchetKey_; }
      }
      
      public const int CounterFieldNumber = 2;
      private bool hasCounter;
      private uint counter_;
      public bool HasCounter {
        get { return hasCounter; }
      }
      [global::System.CLSCompliant(false)]
      public uint Counter {
        get { return counter_; }
      }
      
      public const int PreviousCounterFieldNumber = 3;
      private bool hasPreviousCounter;
      private uint previousCounter_;
      public bool HasPreviousCounter {
        get { return hasPreviousCounter; }
      }
      [global::System.CLSCompliant(false)]
      public uint PreviousCounter {
        get { return previousCounter_; }
      }
      
      public const int CiphertextFieldNumber = 4;
      private bool hasCiphertext;
      private pb::ByteString ciphertext_ = pb::ByteString.Empty;
      public bool HasCiphertext {
        get { return hasCiphertext; }
      }
      public pb::ByteString Ciphertext {
        get { return ciphertext_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _signalMessageFieldNames;
        if (hasRatchetKey) {
          output.WriteBytes(1, field_names[3], RatchetKey);
        }
        if (hasCounter) {
          output.WriteUInt32(2, field_names[1], Counter);
        }
        if (hasPreviousCounter) {
          output.WriteUInt32(3, field_names[2], PreviousCounter);
        }
        if (hasCiphertext) {
          output.WriteBytes(4, field_names[0], Ciphertext);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRatchetKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(1, RatchetKey);
        }
        if (hasCounter) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Counter);
        }
        if (hasPreviousCounter) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, PreviousCounter);
        }
        if (hasCiphertext) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, Ciphertext);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SignalMessage ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SignalMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SignalMessage ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SignalMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SignalMessage ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SignalMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SignalMessage ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SignalMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SignalMessage ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SignalMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SignalMessage MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SignalMessage prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SignalMessage, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SignalMessage cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SignalMessage result;
        
        private SignalMessage PrepareBuilder() {
          if (resultIsReadOnly) {
            SignalMessage original = result;
            result = new SignalMessage();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SignalMessage MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.protocol.SignalProtos.SignalMessage.Descriptor; }
        }
        
        public override SignalMessage DefaultInstanceForType {
          get { return global::libsignal.protocol.SignalProtos.SignalMessage.DefaultInstance; }
        }
        
        public override SignalMessage BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SignalMessage) {
            return MergeFrom((SignalMessage) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SignalMessage other) {
          if (other == global::libsignal.protocol.SignalProtos.SignalMessage.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasRatchetKey) {
            RatchetKey = other.RatchetKey;
          }
          if (other.HasCounter) {
            Counter = other.Counter;
          }
          if (other.HasPreviousCounter) {
            PreviousCounter = other.PreviousCounter;
          }
          if (other.HasCiphertext) {
            Ciphertext = other.Ciphertext;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_signalMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _signalMessageFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasRatchetKey = input.ReadBytes(ref result.ratchetKey_);
                break;
              }
              case 16: {
                result.hasCounter = input.ReadUInt32(ref result.counter_);
                break;
              }
              case 24: {
                result.hasPreviousCounter = input.ReadUInt32(ref result.previousCounter_);
                break;
              }
              case 34: {
                result.hasCiphertext = input.ReadBytes(ref result.ciphertext_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasRatchetKey {
          get { return result.hasRatchetKey; }
        }
        public pb::ByteString RatchetKey {
          get { return result.RatchetKey; }
          set { SetRatchetKey(value); }
        }
        public Builder SetRatchetKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRatchetKey = true;
          result.ratchetKey_ = value;
          return this;
        }
        public Builder ClearRatchetKey() {
          PrepareBuilder();
          result.hasRatchetKey = false;
          result.ratchetKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasCounter {
          get { return result.hasCounter; }
        }
        [global::System.CLSCompliant(false)]
        public uint Counter {
          get { return result.Counter; }
          set { SetCounter(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetCounter(uint value) {
          PrepareBuilder();
          result.hasCounter = true;
          result.counter_ = value;
          return this;
        }
        public Builder ClearCounter() {
          PrepareBuilder();
          result.hasCounter = false;
          result.counter_ = 0;
          return this;
        }
        
        public bool HasPreviousCounter {
          get { return result.hasPreviousCounter; }
        }
        [global::System.CLSCompliant(false)]
        public uint PreviousCounter {
          get { return result.PreviousCounter; }
          set { SetPreviousCounter(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetPreviousCounter(uint value) {
          PrepareBuilder();
          result.hasPreviousCounter = true;
          result.previousCounter_ = value;
          return this;
        }
        public Builder ClearPreviousCounter() {
          PrepareBuilder();
          result.hasPreviousCounter = false;
          result.previousCounter_ = 0;
          return this;
        }
        
        public bool HasCiphertext {
          get { return result.hasCiphertext; }
        }
        public pb::ByteString Ciphertext {
          get { return result.Ciphertext; }
          set { SetCiphertext(value); }
        }
        public Builder SetCiphertext(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasCiphertext = true;
          result.ciphertext_ = value;
          return this;
        }
        public Builder ClearCiphertext() {
          PrepareBuilder();
          result.hasCiphertext = false;
          result.ciphertext_ = pb::ByteString.Empty;
          return this;
        }
      }
      static SignalMessage() {
        object.ReferenceEquals(global::libsignal.protocol.SignalProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class PreKeySignalMessage : pb::GeneratedMessage<PreKeySignalMessage, PreKeySignalMessage.Builder> {
      private PreKeySignalMessage() { }
      private static readonly PreKeySignalMessage defaultInstance = new PreKeySignalMessage().MakeReadOnly();
      private static readonly string[] _preKeySignalMessageFieldNames = new string[] { "baseKey", "identityKey", "message", "preKeyId", "registrationId", "signedPreKeyId" };
      private static readonly uint[] _preKeySignalMessageFieldTags = new uint[] { 18, 26, 34, 8, 40, 48 };
      public static PreKeySignalMessage DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override PreKeySignalMessage DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override PreKeySignalMessage ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.protocol.SignalProtos.internal__static_PreKeySignalMessage__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<PreKeySignalMessage, PreKeySignalMessage.Builder> InternalFieldAccessors {
        get { return global::libsignal.protocol.SignalProtos.internal__static_PreKeySignalMessage__FieldAccessorTable; }
      }
      
      public const int RegistrationIdFieldNumber = 5;
      private bool hasRegistrationId;
      private uint registrationId_;
      public bool HasRegistrationId {
        get { return hasRegistrationId; }
      }
      [global::System.CLSCompliant(false)]
      public uint RegistrationId {
        get { return registrationId_; }
      }
      
      public const int PreKeyIdFieldNumber = 1;
      private bool hasPreKeyId;
      private uint preKeyId_;
      public bool HasPreKeyId {
        get { return hasPreKeyId; }
      }
      [global::System.CLSCompliant(false)]
      public uint PreKeyId {
        get { return preKeyId_; }
      }
      
      public const int SignedPreKeyIdFieldNumber = 6;
      private bool hasSignedPreKeyId;
      private uint signedPreKeyId_;
      public bool HasSignedPreKeyId {
        get { return hasSignedPreKeyId; }
      }
      [global::System.CLSCompliant(false)]
      public uint SignedPreKeyId {
        get { return signedPreKeyId_; }
      }
      
      public const int BaseKeyFieldNumber = 2;
      private bool hasBaseKey;
      private pb::ByteString baseKey_ = pb::ByteString.Empty;
      public bool HasBaseKey {
        get { return hasBaseKey; }
      }
      public pb::ByteString BaseKey {
        get { return baseKey_; }
      }
      
      public const int IdentityKeyFieldNumber = 3;
      private bool hasIdentityKey;
      private pb::ByteString identityKey_ = pb::ByteString.Empty;
      public bool HasIdentityKey {
        get { return hasIdentityKey; }
      }
      public pb::ByteString IdentityKey {
        get { return identityKey_; }
      }
      
      public const int MessageFieldNumber = 4;
      private bool hasMessage;
      private pb::ByteString message_ = pb::ByteString.Empty;
      public bool HasMessage {
        get { return hasMessage; }
      }
      public pb::ByteString Message {
        get { return message_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _preKeySignalMessageFieldNames;
        if (hasPreKeyId) {
          output.WriteUInt32(1, field_names[3], PreKeyId);
        }
        if (hasBaseKey) {
          output.WriteBytes(2, field_names[0], BaseKey);
        }
        if (hasIdentityKey) {
          output.WriteBytes(3, field_names[1], IdentityKey);
        }
        if (hasMessage) {
          output.WriteBytes(4, field_names[2], Message);
        }
        if (hasRegistrationId) {
          output.WriteUInt32(5, field_names[4], RegistrationId);
        }
        if (hasSignedPreKeyId) {
          output.WriteUInt32(6, field_names[5], SignedPreKeyId);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRegistrationId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, RegistrationId);
        }
        if (hasPreKeyId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, PreKeyId);
        }
        if (hasSignedPreKeyId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(6, SignedPreKeyId);
        }
        if (hasBaseKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, BaseKey);
        }
        if (hasIdentityKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, IdentityKey);
        }
        if (hasMessage) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, Message);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static PreKeySignalMessage ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static PreKeySignalMessage ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static PreKeySignalMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static PreKeySignalMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private PreKeySignalMessage MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(PreKeySignalMessage prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<PreKeySignalMessage, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(PreKeySignalMessage cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private PreKeySignalMessage result;
        
        private PreKeySignalMessage PrepareBuilder() {
          if (resultIsReadOnly) {
            PreKeySignalMessage original = result;
            result = new PreKeySignalMessage();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override PreKeySignalMessage MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.protocol.SignalProtos.PreKeySignalMessage.Descriptor; }
        }
        
        public override PreKeySignalMessage DefaultInstanceForType {
          get { return global::libsignal.protocol.SignalProtos.PreKeySignalMessage.DefaultInstance; }
        }
        
        public override PreKeySignalMessage BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is PreKeySignalMessage) {
            return MergeFrom((PreKeySignalMessage) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(PreKeySignalMessage other) {
          if (other == global::libsignal.protocol.SignalProtos.PreKeySignalMessage.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasRegistrationId) {
            RegistrationId = other.RegistrationId;
          }
          if (other.HasPreKeyId) {
            PreKeyId = other.PreKeyId;
          }
          if (other.HasSignedPreKeyId) {
            SignedPreKeyId = other.SignedPreKeyId;
          }
          if (other.HasBaseKey) {
            BaseKey = other.BaseKey;
          }
          if (other.HasIdentityKey) {
            IdentityKey = other.IdentityKey;
          }
          if (other.HasMessage) {
            Message = other.Message;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_preKeySignalMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _preKeySignalMessageFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasPreKeyId = input.ReadUInt32(ref result.preKeyId_);
                break;
              }
              case 18: {
                result.hasBaseKey = input.ReadBytes(ref result.baseKey_);
                break;
              }
              case 26: {
                result.hasIdentityKey = input.ReadBytes(ref result.identityKey_);
                break;
              }
              case 34: {
                result.hasMessage = input.ReadBytes(ref result.message_);
                break;
              }
              case 40: {
                result.hasRegistrationId = input.ReadUInt32(ref result.registrationId_);
                break;
              }
              case 48: {
                result.hasSignedPreKeyId = input.ReadUInt32(ref result.signedPreKeyId_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasRegistrationId {
          get { return result.hasRegistrationId; }
        }
        [global::System.CLSCompliant(false)]
        public uint RegistrationId {
          get { return result.RegistrationId; }
          set { SetRegistrationId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetRegistrationId(uint value) {
          PrepareBuilder();
          result.hasRegistrationId = true;
          result.registrationId_ = value;
          return this;
        }
        public Builder ClearRegistrationId() {
          PrepareBuilder();
          result.hasRegistrationId = false;
          result.registrationId_ = 0;
          return this;
        }
        
        public bool HasPreKeyId {
          get { return result.hasPreKeyId; }
        }
        [global::System.CLSCompliant(false)]
        public uint PreKeyId {
          get { return result.PreKeyId; }
          set { SetPreKeyId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetPreKeyId(uint value) {
          PrepareBuilder();
          result.hasPreKeyId = true;
          result.preKeyId_ = value;
          return this;
        }
        public Builder ClearPreKeyId() {
          PrepareBuilder();
          result.hasPreKeyId = false;
          result.preKeyId_ = 0;
          return this;
        }
        
        public bool HasSignedPreKeyId {
          get { return result.hasSignedPreKeyId; }
        }
        [global::System.CLSCompliant(false)]
        public uint SignedPreKeyId {
          get { return result.SignedPreKeyId; }
          set { SetSignedPreKeyId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetSignedPreKeyId(uint value) {
          PrepareBuilder();
          result.hasSignedPreKeyId = true;
          result.signedPreKeyId_ = value;
          return this;
        }
        public Builder ClearSignedPreKeyId() {
          PrepareBuilder();
          result.hasSignedPreKeyId = false;
          result.signedPreKeyId_ = 0;
          return this;
        }
        
        public bool HasBaseKey {
          get { return result.hasBaseKey; }
        }
        public pb::ByteString BaseKey {
          get { return result.BaseKey; }
          set { SetBaseKey(value); }
        }
        public Builder SetBaseKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasBaseKey = true;
          result.baseKey_ = value;
          return this;
        }
        public Builder ClearBaseKey() {
          PrepareBuilder();
          result.hasBaseKey = false;
          result.baseKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasIdentityKey {
          get { return result.hasIdentityKey; }
        }
        public pb::ByteString IdentityKey {
          get { return result.IdentityKey; }
          set { SetIdentityKey(value); }
        }
        public Builder SetIdentityKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasIdentityKey = true;
          result.identityKey_ = value;
          return this;
        }
        public Builder ClearIdentityKey() {
          PrepareBuilder();
          result.hasIdentityKey = false;
          result.identityKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasMessage {
          get { return result.hasMessage; }
        }
        public pb::ByteString Message {
          get { return result.Message; }
          set { SetMessage(value); }
        }
        public Builder SetMessage(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasMessage = true;
          result.message_ = value;
          return this;
        }
        public Builder ClearMessage() {
          PrepareBuilder();
          result.hasMessage = false;
          result.message_ = pb::ByteString.Empty;
          return this;
        }
      }
      static PreKeySignalMessage() {
        object.ReferenceEquals(global::libsignal.protocol.SignalProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class KeyExchangeMessage : pb::GeneratedMessage<KeyExchangeMessage, KeyExchangeMessage.Builder> {
      private KeyExchangeMessage() { }
      private static readonly KeyExchangeMessage defaultInstance = new KeyExchangeMessage().MakeReadOnly();
      private static readonly string[] _keyExchangeMessageFieldNames = new string[] { "baseKey", "baseKeySignature", "id", "identityKey", "ratchetKey" };
      private static readonly uint[] _keyExchangeMessageFieldTags = new uint[] { 18, 42, 8, 34, 26 };
      public static KeyExchangeMessage DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override KeyExchangeMessage DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override KeyExchangeMessage ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.protocol.SignalProtos.internal__static_KeyExchangeMessage__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<KeyExchangeMessage, KeyExchangeMessage.Builder> InternalFieldAccessors {
        get { return global::libsignal.protocol.SignalProtos.internal__static_KeyExchangeMessage__FieldAccessorTable; }
      }
      
      public const int IdFieldNumber = 1;
      private bool hasId;
      private uint id_;
      public bool HasId {
        get { return hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return id_; }
      }
      
      public const int BaseKeyFieldNumber = 2;
      private bool hasBaseKey;
      private pb::ByteString baseKey_ = pb::ByteString.Empty;
      public bool HasBaseKey {
        get { return hasBaseKey; }
      }
      public pb::ByteString BaseKey {
        get { return baseKey_; }
      }
      
      public const int RatchetKeyFieldNumber = 3;
      private bool hasRatchetKey;
      private pb::ByteString ratchetKey_ = pb::ByteString.Empty;
      public bool HasRatchetKey {
        get { return hasRatchetKey; }
      }
      public pb::ByteString RatchetKey {
        get { return ratchetKey_; }
      }
      
      public const int IdentityKeyFieldNumber = 4;
      private bool hasIdentityKey;
      private pb::ByteString identityKey_ = pb::ByteString.Empty;
      public bool HasIdentityKey {
        get { return hasIdentityKey; }
      }
      public pb::ByteString IdentityKey {
        get { return identityKey_; }
      }
      
      public const int BaseKeySignatureFieldNumber = 5;
      private bool hasBaseKeySignature;
      private pb::ByteString baseKeySignature_ = pb::ByteString.Empty;
      public bool HasBaseKeySignature {
        get { return hasBaseKeySignature; }
      }
      public pb::ByteString BaseKeySignature {
        get { return baseKeySignature_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _keyExchangeMessageFieldNames;
        if (hasId) {
          output.WriteUInt32(1, field_names[2], Id);
        }
        if (hasBaseKey) {
          output.WriteBytes(2, field_names[0], BaseKey);
        }
        if (hasRatchetKey) {
          output.WriteBytes(3, field_names[4], RatchetKey);
        }
        if (hasIdentityKey) {
          output.WriteBytes(4, field_names[3], IdentityKey);
        }
        if (hasBaseKeySignature) {
          output.WriteBytes(5, field_names[1], BaseKeySignature);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasBaseKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(2, BaseKey);
        }
        if (hasRatchetKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, RatchetKey);
        }
        if (hasIdentityKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, IdentityKey);
        }
        if (hasBaseKeySignature) {
          size += pb::CodedOutputStream.ComputeBytesSize(5, BaseKeySignature);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static KeyExchangeMessage ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static KeyExchangeMessage ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static KeyExchangeMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static KeyExchangeMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private KeyExchangeMessage MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(KeyExchangeMessage prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<KeyExchangeMessage, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(KeyExchangeMessage cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private KeyExchangeMessage result;
        
        private KeyExchangeMessage PrepareBuilder() {
          if (resultIsReadOnly) {
            KeyExchangeMessage original = result;
            result = new KeyExchangeMessage();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override KeyExchangeMessage MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.protocol.SignalProtos.KeyExchangeMessage.Descriptor; }
        }
        
        public override KeyExchangeMessage DefaultInstanceForType {
          get { return global::libsignal.protocol.SignalProtos.KeyExchangeMessage.DefaultInstance; }
        }
        
        public override KeyExchangeMessage BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is KeyExchangeMessage) {
            return MergeFrom((KeyExchangeMessage) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(KeyExchangeMessage other) {
          if (other == global::libsignal.protocol.SignalProtos.KeyExchangeMessage.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasBaseKey) {
            BaseKey = other.BaseKey;
          }
          if (other.HasRatchetKey) {
            RatchetKey = other.RatchetKey;
          }
          if (other.HasIdentityKey) {
            IdentityKey = other.IdentityKey;
          }
          if (other.HasBaseKeySignature) {
            BaseKeySignature = other.BaseKeySignature;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_keyExchangeMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _keyExchangeMessageFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasId = input.ReadUInt32(ref result.id_);
                break;
              }
              case 18: {
                result.hasBaseKey = input.ReadBytes(ref result.baseKey_);
                break;
              }
              case 26: {
                result.hasRatchetKey = input.ReadBytes(ref result.ratchetKey_);
                break;
              }
              case 34: {
                result.hasIdentityKey = input.ReadBytes(ref result.identityKey_);
                break;
              }
              case 42: {
                result.hasBaseKeySignature = input.ReadBytes(ref result.baseKeySignature_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasId {
          get { return result.hasId; }
        }
        [global::System.CLSCompliant(false)]
        public uint Id {
          get { return result.Id; }
          set { SetId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetId(uint value) {
          PrepareBuilder();
          result.hasId = true;
          result.id_ = value;
          return this;
        }
        public Builder ClearId() {
          PrepareBuilder();
          result.hasId = false;
          result.id_ = 0;
          return this;
        }
        
        public bool HasBaseKey {
          get { return result.hasBaseKey; }
        }
        public pb::ByteString BaseKey {
          get { return result.BaseKey; }
          set { SetBaseKey(value); }
        }
        public Builder SetBaseKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasBaseKey = true;
          result.baseKey_ = value;
          return this;
        }
        public Builder ClearBaseKey() {
          PrepareBuilder();
          result.hasBaseKey = false;
          result.baseKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasRatchetKey {
          get { return result.hasRatchetKey; }
        }
        public pb::ByteString RatchetKey {
          get { return result.RatchetKey; }
          set { SetRatchetKey(value); }
        }
        public Builder SetRatchetKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRatchetKey = true;
          result.ratchetKey_ = value;
          return this;
        }
        public Builder ClearRatchetKey() {
          PrepareBuilder();
          result.hasRatchetKey = false;
          result.ratchetKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasIdentityKey {
          get { return result.hasIdentityKey; }
        }
        public pb::ByteString IdentityKey {
          get { return result.IdentityKey; }
          set { SetIdentityKey(value); }
        }
        public Builder SetIdentityKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasIdentityKey = true;
          result.identityKey_ = value;
          return this;
        }
        public Builder ClearIdentityKey() {
          PrepareBuilder();
          result.hasIdentityKey = false;
          result.identityKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasBaseKeySignature {
          get { return result.hasBaseKeySignature; }
        }
        public pb::ByteString BaseKeySignature {
          get { return result.BaseKeySignature; }
          set { SetBaseKeySignature(value); }
        }
        public Builder SetBaseKeySignature(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasBaseKeySignature = true;
          result.baseKeySignature_ = value;
          return this;
        }
        public Builder ClearBaseKeySignature() {
          PrepareBuilder();
          result.hasBaseKeySignature = false;
          result.baseKeySignature_ = pb::ByteString.Empty;
          return this;
        }
      }
      static KeyExchangeMessage() {
        object.ReferenceEquals(global::libsignal.protocol.SignalProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SenderKeyMessage : pb::GeneratedMessage<SenderKeyMessage, SenderKeyMessage.Builder> {
      private SenderKeyMessage() { }
      private static readonly SenderKeyMessage defaultInstance = new SenderKeyMessage().MakeReadOnly();
      private static readonly string[] _senderKeyMessageFieldNames = new string[] { "ciphertext", "id", "iteration" };
      private static readonly uint[] _senderKeyMessageFieldTags = new uint[] { 26, 8, 16 };
      public static SenderKeyMessage DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SenderKeyMessage DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SenderKeyMessage ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SenderKeyMessage__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SenderKeyMessage, SenderKeyMessage.Builder> InternalFieldAccessors {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SenderKeyMessage__FieldAccessorTable; }
      }
      
      public const int IdFieldNumber = 1;
      private bool hasId;
      private uint id_;
      public bool HasId {
        get { return hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return id_; }
      }
      
      public const int IterationFieldNumber = 2;
      private bool hasIteration;
      private uint iteration_;
      public bool HasIteration {
        get { return hasIteration; }
      }
      [global::System.CLSCompliant(false)]
      public uint Iteration {
        get { return iteration_; }
      }
      
      public const int CiphertextFieldNumber = 3;
      private bool hasCiphertext;
      private pb::ByteString ciphertext_ = pb::ByteString.Empty;
      public bool HasCiphertext {
        get { return hasCiphertext; }
      }
      public pb::ByteString Ciphertext {
        get { return ciphertext_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _senderKeyMessageFieldNames;
        if (hasId) {
          output.WriteUInt32(1, field_names[1], Id);
        }
        if (hasIteration) {
          output.WriteUInt32(2, field_names[2], Iteration);
        }
        if (hasCiphertext) {
          output.WriteBytes(3, field_names[0], Ciphertext);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasIteration) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Iteration);
        }
        if (hasCiphertext) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, Ciphertext);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SenderKeyMessage ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyMessage ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SenderKeyMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SenderKeyMessage MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SenderKeyMessage prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SenderKeyMessage, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SenderKeyMessage cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SenderKeyMessage result;
        
        private SenderKeyMessage PrepareBuilder() {
          if (resultIsReadOnly) {
            SenderKeyMessage original = result;
            result = new SenderKeyMessage();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SenderKeyMessage MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.protocol.SignalProtos.SenderKeyMessage.Descriptor; }
        }
        
        public override SenderKeyMessage DefaultInstanceForType {
          get { return global::libsignal.protocol.SignalProtos.SenderKeyMessage.DefaultInstance; }
        }
        
        public override SenderKeyMessage BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SenderKeyMessage) {
            return MergeFrom((SenderKeyMessage) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SenderKeyMessage other) {
          if (other == global::libsignal.protocol.SignalProtos.SenderKeyMessage.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasIteration) {
            Iteration = other.Iteration;
          }
          if (other.HasCiphertext) {
            Ciphertext = other.Ciphertext;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_senderKeyMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _senderKeyMessageFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasId = input.ReadUInt32(ref result.id_);
                break;
              }
              case 16: {
                result.hasIteration = input.ReadUInt32(ref result.iteration_);
                break;
              }
              case 26: {
                result.hasCiphertext = input.ReadBytes(ref result.ciphertext_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasId {
          get { return result.hasId; }
        }
        [global::System.CLSCompliant(false)]
        public uint Id {
          get { return result.Id; }
          set { SetId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetId(uint value) {
          PrepareBuilder();
          result.hasId = true;
          result.id_ = value;
          return this;
        }
        public Builder ClearId() {
          PrepareBuilder();
          result.hasId = false;
          result.id_ = 0;
          return this;
        }
        
        public bool HasIteration {
          get { return result.hasIteration; }
        }
        [global::System.CLSCompliant(false)]
        public uint Iteration {
          get { return result.Iteration; }
          set { SetIteration(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetIteration(uint value) {
          PrepareBuilder();
          result.hasIteration = true;
          result.iteration_ = value;
          return this;
        }
        public Builder ClearIteration() {
          PrepareBuilder();
          result.hasIteration = false;
          result.iteration_ = 0;
          return this;
        }
        
        public bool HasCiphertext {
          get { return result.hasCiphertext; }
        }
        public pb::ByteString Ciphertext {
          get { return result.Ciphertext; }
          set { SetCiphertext(value); }
        }
        public Builder SetCiphertext(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasCiphertext = true;
          result.ciphertext_ = value;
          return this;
        }
        public Builder ClearCiphertext() {
          PrepareBuilder();
          result.hasCiphertext = false;
          result.ciphertext_ = pb::ByteString.Empty;
          return this;
        }
      }
      static SenderKeyMessage() {
        object.ReferenceEquals(global::libsignal.protocol.SignalProtos.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class SenderKeyDistributionMessage : pb::GeneratedMessage<SenderKeyDistributionMessage, SenderKeyDistributionMessage.Builder> {
      private SenderKeyDistributionMessage() { }
      private static readonly SenderKeyDistributionMessage defaultInstance = new SenderKeyDistributionMessage().MakeReadOnly();
      private static readonly string[] _senderKeyDistributionMessageFieldNames = new string[] { "chainKey", "id", "iteration", "signingKey" };
      private static readonly uint[] _senderKeyDistributionMessageFieldTags = new uint[] { 26, 8, 16, 34 };
      public static SenderKeyDistributionMessage DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override SenderKeyDistributionMessage DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override SenderKeyDistributionMessage ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SenderKeyDistributionMessage__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<SenderKeyDistributionMessage, SenderKeyDistributionMessage.Builder> InternalFieldAccessors {
        get { return global::libsignal.protocol.SignalProtos.internal__static_SenderKeyDistributionMessage__FieldAccessorTable; }
      }
      
      public const int IdFieldNumber = 1;
      private bool hasId;
      private uint id_;
      public bool HasId {
        get { return hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return id_; }
      }
      
      public const int IterationFieldNumber = 2;
      private bool hasIteration;
      private uint iteration_;
      public bool HasIteration {
        get { return hasIteration; }
      }
      [global::System.CLSCompliant(false)]
      public uint Iteration {
        get { return iteration_; }
      }
      
      public const int ChainKeyFieldNumber = 3;
      private bool hasChainKey;
      private pb::ByteString chainKey_ = pb::ByteString.Empty;
      public bool HasChainKey {
        get { return hasChainKey; }
      }
      public pb::ByteString ChainKey {
        get { return chainKey_; }
      }
      
      public const int SigningKeyFieldNumber = 4;
      private bool hasSigningKey;
      private pb::ByteString signingKey_ = pb::ByteString.Empty;
      public bool HasSigningKey {
        get { return hasSigningKey; }
      }
      public pb::ByteString SigningKey {
        get { return signingKey_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        CalcSerializedSize();
        string[] field_names = _senderKeyDistributionMessageFieldNames;
        if (hasId) {
          output.WriteUInt32(1, field_names[1], Id);
        }
        if (hasIteration) {
          output.WriteUInt32(2, field_names[2], Iteration);
        }
        if (hasChainKey) {
          output.WriteBytes(3, field_names[0], ChainKey);
        }
        if (hasSigningKey) {
          output.WriteBytes(4, field_names[3], SigningKey);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          return CalcSerializedSize();
        }
      }
      
      private int CalcSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
        }
        if (hasIteration) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Iteration);
        }
        if (hasChainKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(3, ChainKey);
        }
        if (hasSigningKey) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, SigningKey);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
      public static SenderKeyDistributionMessage ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static SenderKeyDistributionMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private SenderKeyDistributionMessage MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(SenderKeyDistributionMessage prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<SenderKeyDistributionMessage, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(SenderKeyDistributionMessage cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private SenderKeyDistributionMessage result;
        
        private SenderKeyDistributionMessage PrepareBuilder() {
          if (resultIsReadOnly) {
            SenderKeyDistributionMessage original = result;
            result = new SenderKeyDistributionMessage();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override SenderKeyDistributionMessage MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage.Descriptor; }
        }
        
        public override SenderKeyDistributionMessage DefaultInstanceForType {
          get { return global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage.DefaultInstance; }
        }
        
        public override SenderKeyDistributionMessage BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is SenderKeyDistributionMessage) {
            return MergeFrom((SenderKeyDistributionMessage) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(SenderKeyDistributionMessage other) {
          if (other == global::libsignal.protocol.SignalProtos.SenderKeyDistributionMessage.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasIteration) {
            Iteration = other.Iteration;
          }
          if (other.HasChainKey) {
            ChainKey = other.ChainKey;
          }
          if (other.HasSigningKey) {
            SigningKey = other.SigningKey;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_senderKeyDistributionMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _senderKeyDistributionMessageFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasId = input.ReadUInt32(ref result.id_);
                break;
              }
              case 16: {
                result.hasIteration = input.ReadUInt32(ref result.iteration_);
                break;
              }
              case 26: {
                result.hasChainKey = input.ReadBytes(ref result.chainKey_);
                break;
              }
              case 34: {
                result.hasSigningKey = input.ReadBytes(ref result.signingKey_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasId {
          get { return result.hasId; }
        }
        [global::System.CLSCompliant(false)]
        public uint Id {
          get { return result.Id; }
          set { SetId(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetId(uint value) {
          PrepareBuilder();
          result.hasId = true;
          result.id_ = value;
          return this;
        }
        public Builder ClearId() {
          PrepareBuilder();
          result.hasId = false;
          result.id_ = 0;
          return this;
        }
        
        public bool HasIteration {
          get { return result.hasIteration; }
        }
        [global::System.CLSCompliant(false)]
        public uint Iteration {
          get { return result.Iteration; }
          set { SetIteration(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetIteration(uint value) {
          PrepareBuilder();
          result.hasIteration = true;
          result.iteration_ = value;
          return this;
        }
        public Builder ClearIteration() {
          PrepareBuilder();
          result.hasIteration = false;
          result.iteration_ = 0;
          return this;
        }
        
        public bool HasChainKey {
          get { return result.hasChainKey; }
        }
        public pb::ByteString ChainKey {
          get { return result.ChainKey; }
          set { SetChainKey(value); }
        }
        public Builder SetChainKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasChainKey = true;
          result.chainKey_ = value;
          return this;
        }
        public Builder ClearChainKey() {
          PrepareBuilder();
          result.hasChainKey = false;
          result.chainKey_ = pb::ByteString.Empty;
          return this;
        }
        
        public bool HasSigningKey {
          get { return result.hasSigningKey; }
        }
        public pb::ByteString SigningKey {
          get { return result.SigningKey; }
          set { SetSigningKey(value); }
        }
        public Builder SetSigningKey(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasSigningKey = true;
          result.signingKey_ = value;
          return this;
        }
        public Builder ClearSigningKey() {
          PrepareBuilder();
          result.hasSigningKey = false;
          result.signingKey_ = pb::ByteString.Empty;
          return this;
        }
      }
      static SenderKeyDistributionMessage() {
        object.ReferenceEquals(global::libsignal.protocol.SignalProtos.Descriptor, null);
      }
    }
    
    #endregion
    
  }
}

#endregion Designer generated code
